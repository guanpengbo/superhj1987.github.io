<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | 后端技术杂谈 | 飒然Hang]]></title>
  <link href="http://www.rowkey.me/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://www.rowkey.me/"/>
  <updated>2017-08-29T15:56:45+08:00</updated>
  <id>http://www.rowkey.me/</id>
  <author>
    <name><![CDATA[飒然Hang]]></name>
    <email><![CDATA[superhj1987@126.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[谈谈架构]]></title>
    <link href="http://www.rowkey.me/blog/2017/08/24/arch/"/>
    <updated>2017-08-24T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/08/24/arch</id>
    <content type="html"><![CDATA[<p>之前开头的《架构设计原则》一文一直没有把坑填上。而最近在公司内部做了一次架构交流/培训，把架构的概念、架构的形式、架构设计原则都做了阐述，正好算是对此文的完成和补充。</p>

<p><a href="http://www.rowkey.me/arch-ppt/index.html" target="_blank">PPT观看</a></p>

<!--more-->


<p><img src="//images/blog_images/arch/arch-2.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-3.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-4.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-5.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-6.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-7.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-8.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-9.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-10.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-11.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-12.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-13.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-14.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-15.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-16.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-17.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-18.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-19.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-20.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-21.jpeg" alt="" />
<img src="//images/blog_images/arch/arch-22.jpeg" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Java中提升函数以更好地“函数式”编程]]></title>
    <link href="http://www.rowkey.me/blog/2017/08/18/lift-functions/"/>
    <updated>2017-08-18T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/08/18/lift-functions</id>
    <content type="html"><![CDATA[<p>Java8中的Stream和Optional给我们带来了函数式编程的乐趣，但Java仍然缺少很多函数编程的关键特性。Lambda表达式、Optional和Stream只是函数式编程的冰山一角。这也导致了<a href="https://github.com/vavr-io/vavr">varvr</a>和<a href="https://github.com/functionaljava/functionaljava">functionlajava</a>这些类库的出现，他们都源于Haskell这个纯函数式编程语言。</p>

<p>如果想要更加地“函数式”编程，那么首先要注意的是不要过早的中断monad(一种设计模式，表示将一个运算过程通过函数拆解成互相连接的多个步骤。只要提供下一步运算所需的函数，整个运算就会自动进行下去, Optional、Stream都是monad)，比如，很多人经常会在还不需要的时候就调用了Optional.get()和Stream.collect()提前终止monad。本文主要讲述如何通过提升方法来使得代码更&#8221;函数式&#8221;。</p>

<!--more-->


<p>假设有一个接口可以对数字进行计算。</p>

<pre><code>public interface Math {
    int multiply(int a, int b);
    double divide(int a, int b);
    ..
}
</code></pre>

<p>我们要使用这个接口来对使用Optional做包装的数字做计算。</p>

<pre><code>public interface NumberProvider {
    Optional&lt;Integer&gt; getNumber();
}
</code></pre>

<p>接着我们来实现一个方法能够返回两个数字相除的结果，结果用Optional包装。如果这两个数字有一个为空则返回空Optional。如下：</p>

<pre><code>public Optional&lt;Double&gt; divideFirstTwo(NumberProvider numberProvider, Math math) {
    Optional&lt;Integer&gt; first = numberProvider.getNumber();
    Optional&lt;Integer&gt; second = numberProvider.getNumber();
    if(first.isPresent() &amp;&amp; second.isPresent()) {
        double result = math.divide(first.get(), second.get());
        return Optional.of(result);
    } else {
        return Optional.empty();
    }
}
</code></pre>

<p>上面的代码非常不优雅，有大量的代码都是在做Optional的包装和解包装。可以让上面的代码变得更加“函数式”，如下：</p>

<pre><code>public Optional&lt;Double&gt; divideFirstTwo(NumberProvider numberProvider, Math math) {
    return numberProvider.getNumber()
           .flatMap(first -&gt; numberProvider.getNumber()
                                     .map(second -&gt; math.divide(first, second)));
}
</code></pre>

<p>这样代码少了很多，也优雅了很多。先调用第一个Optional的flatMap，再在lambda中调用第二个Optional的map，进一步可以抽取出一个提升方法：</p>

<pre><code>public interface Optionals {
    static &lt;R, T, Z&gt; BiFunction&lt;Optional&lt;T&gt;, Optional&lt;R&gt;, Optional&lt;Z&gt;&gt; lift(BiFunction&lt;? super T, ? super R, ? extends Z&gt; function) {
        return (left, right) -&gt; left.flatMap(leftVal -&gt; right.map(rightVal -&gt; function.apply(leftVal, rightVal)));
    }
}
</code></pre>

<p>如上，可知这个方法提升能够提升任何具有两个Optional参数、一个Optional结果的函数，使得被提升的函数具有Optional的一个特性：如果一个参数是空的，那么结果就是空的。如果JDK抽取flatMap和map到一个公共接口，如Monad，那么我们可以为Java Monad的每一个实例(Stream、Optional、自己的实现类)实现一个公共的提升函数。但现实是我们不得不为每一个实例都复制粘贴上面的代码。最终的divideFirstTwo代码如下：</p>

<pre><code>import static com.ps.functional.monad.optional.Optionals.lift;
...
public Optional&lt;Double&gt; divideFirstTwo(NumberProvider numberProvider, Math math) {
    return lift(math::divide).apply(numberProvider.getNumber(), numberProvider.getNumber());
}
</code></pre>

<p><strong>ps: 此文内容来自<a href="https://dzone.com/articles/lifting-functions-to-work-with-monads-in-java?edition=311409&amp;edition=0&amp;utm_source=Zone%20Newsletter&amp;utm_medium=email&amp;utm_campaign=java%202017-08-01">https://dzone.com/articles/lifting-functions-to-work-with-monads-in-java?edition=311409&amp;edition=0&amp;utm_source=Zone%20Newsletter&amp;utm_medium=email&amp;utm_campaign=java%202017-08-01</a>，加入了本人的理解和认知。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《Java工程师修炼之道》内容概览]]></title>
    <link href="http://www.rowkey.me/blog/2017/08/10/pragmatic-java-engineer/"/>
    <updated>2017-08-10T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/08/10/pragmatic-java-engineer</id>
    <content type="html"><![CDATA[<p>最近几个月由于工作和正在筹备《Java工程师修炼之道》一书的原因一直没有写新的文章。不过，忙里偷闲，自己陆续读完了《格鲁夫给经理人的第一课》、《架构真经》、《聊聊架构》这几本书，收获了不少干货，之前自己挖坑的《一些架构设计原则》一文后面会尽快填上。本文则先介绍一下《Java工程师修炼之道》一书^_^。</p>

<p>《Java工程师修炼之道》一书主要内容是Java后端工程师必备的基本技能大纲。内容主要来自于公司内的后端工程师学习计划、自己以前的一些博客文章和自己从业以来积累的知识库。但由于后端工程师的每一个技能点都具有一定的深度，都不是一两篇文章就能讲述清楚的，因此本书不可能对每一个技能点都讲的特别透彻。</p>

<p>本书可以看做是一本Java工程师的入职指南，也可以看做一本串联Java后端技能点的参考手册。对其中每一个技能点的学习，推荐通过他们的官方文档来深入学习，此外，本书也给出了自己觉得有价值的参考学习书籍。</p>

<!--more-->


<p>初步的目录如下：</p>

<ul>
<li><p>第一章 后端技术导言</p>

<ul>
<li>1.1 后端基础设施</li>
<li>1.2 Java后端技术概览</li>
<li>1.3 如何学习后端技术</li>
</ul>
</li>
<li><p>第二章 Java项目工程化</p>

<ul>
<li>2.1 项目构建</li>
<li>2.2 代码版本协作</li>
<li>2.3 代码质量</li>
</ul>
</li>
<li><p>第三章 开发框架</p>

<ul>
<li>3.1 依赖注入</li>
<li>3.2 对象关系映射</li>
<li>3.3 日志</li>
<li>3.4 Web MVC</li>
</ul>
</li>
<li><p>第四章 Spring</p>

<ul>
<li>4.1 Spring Core</li>
<li>4.2 数据操作</li>
<li>4.3 Spring Boot</li>
<li>4.4 常用组件</li>
<li>4.5 总结</li>
</ul>
</li>
<li><p>第五章 数据存储</p>

<ul>
<li>5.1 关系型数据库</li>
<li>5.2 NoSQL数据库</li>
<li>5.3 缓存</li>
<li>5.4 搜索引擎</li>
</ul>
</li>
<li><p>第六章 数据通信</p>

<ul>
<li>6.1 RESTful</li>
<li>6.2 RPC</li>
<li>6.3 消息队列</li>
</ul>
</li>
<li><p>第七章 Java编程进阶</p>

<ul>
<li>7.1 Java内存管理</li>
<li>7.2 Java网络编程</li>
<li>7.3 Java并发编程</li>
<li>7.4 Java开发武器</li>
<li>7.5 New Java</li>
<li>7.6 总结</li>
</ul>
</li>
<li><p>第八章 性能调优</p>

<ul>
<li>8.1 调优准备</li>
<li>8.2 性能分析</li>
<li>8.3 性能调优</li>
</ul>
</li>
<li><p>第九章 安全技术</p>

<ul>
<li>9.1 Java加密</li>
<li>9.2 HTTPS</li>
<li>9.3 Web安全</li>
</ul>
</li>
</ul>


<p>其中的部分内容，会在此书正式出版后陆续放出。</p>

<p><strong>希望这本书会给想要学习Java后端开发的同学或者还未形成自己技术体系的Java工程师们带来帮助。</strong></p>

<p>题外的，再给我们的新产品打一个广告。</p>

<p>哔哔是一个对话式故事阅读app，对话式故事也叫话本，一个故事就类似于微信的一段对话，形式如下：</p>

<p><img src="//images/blog_images/bibi.png" alt="" /></p>

<p>区别于其他阅读类app，我们还重视社交关系的维护以及故事的直播。</p>

<p><img src="//images/blog_images/bibi-live.png" alt="" /></p>

<p>此外，我们已经吸引了大量优秀故事创作者在我们平台上贡献内容。故事类型丰富多样，故事内容千奇百怪。爱讲段子的段子手能够在这里凭借自己段子的魅力俘获万千粉丝，获得打赏；爱看故事的童鞋也可以在这里追随各种故事达人，看他们直播讲故事/段子，给自己喜欢的作者送礼物。</p>

<p>扫码下载：</p>

<p><img src="//images/blog_images/bibi-url.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM诊断调优CheatSheet]]></title>
    <link href="http://www.rowkey.me/blog/2017/03/23/java-profile-cheatsheet/"/>
    <updated>2017-03-23T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/03/23/java-profile-cheatsheet</id>
    <content type="html"><![CDATA[<p>包含诊断调优java应用的各种命令以及jvm配置示例。</p>

<h2>常用Shell命令</h2>

<ul>
<li><p>查看网络状况</p>

<pre><code>  netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
</code></pre></li>
<li><p>使用top去获取进程cpu使用率；使用/proc文件查看进程所占内存。</p>

<pre><code>  #!/bin/bash
  for i in `ps -ef | egrep -v "awk|$0" | awk '/'$1'/{print $2}'`
  do
      mymem=`cat /proc/$i/status 2&gt; /dev/null | grep VmRSS | awk '{print $2" " $3}'`
      cpu=`top -n 1 -b |awk '/'$i'/{print $9}'`
  done
</code></pre></li>
</ul>


<!--more-->


<h2>常用JDK命令</h2>

<ul>
<li><p>查看类的一些信息，如字节码的版本号、常量池等</p>

<blockquote><p>javap -verbose classname</p></blockquote></li>
<li><p>查看jvm进程</p>

<blockquote><p>jps</p>

<p>jcmd -l</p></blockquote></li>
<li><p>查看进程的gc情况</p>

<blockquote><p>jstat -gcutil [pid] (显示总体情况)</p>

<p>jstat -gc [pid] 1000 10（每隔1秒刷新一次 一共10次）</p></blockquote></li>
<li><p>查看jvm内存使用状况</p>

<blockquote><p>jmap -heap [pid]</p></blockquote></li>
<li><p>查看jvm内存存活的对象：</p>

<blockquote><p>jcmd [pid] GC.class_histogram</p>

<p>jmap -histo:live [pid]</p></blockquote></li>
<li><p>把heap里所有对象都dump下来，无论对象是死是活</p>

<blockquote><p>jmap -dump:format=b,file=xxx.hprof [pid]</p></blockquote></li>
<li><p>先做一次full GC，再dump，只包含仍然存活的对象信息：</p>

<blockquote><p>jcmd [PID] GC.heap_dump [FILENAME]</p>

<p>jmap -dump:format=b,live,file=xxx.hprof [pid]</p></blockquote></li>
<li><p>线程dump</p>

<blockquote><p>jstack [pid] #-m参数可以打印出native栈的信息</p>

<p>jcmd <PID> Thread.print</p>

<p>kill -3 [pid]</p></blockquote></li>
<li><p>查看目前jvm启动的参数</p>

<blockquote><p>jinfo -flags [pid] #有效参数</p>

<p>jcmd [pid] VM.flags #所有参数</p></blockquote></li>
<li><p>查看对应参数的值</p>

<blockquote><p>jinfo -flag [flagName] [pid]</p></blockquote></li>
<li><p>启用/禁止某个参数</p>

<blockquote><p>jinfo -flag [+/-][flagName] [pid]</p></blockquote></li>
<li><p>设置某个参数</p>

<blockquote><p>jinfo -flag [flagName=value] [pid]</p></blockquote></li>
<li><p>查看所有可以设置的参数以及其默认值</p>

<blockquote><p>java -XX:+PrintFlagsInitial</p></blockquote></li>
</ul>


<h2>第三方工具</h2>

<p><strong>========<a href="https://github.com/superhj1987/awesome-scripts/blob/master/README.md">awesome-scripts</a>========</strong></p>

<p><strong>安装:</strong></p>

<p><code>curl -s "https://raw.githubusercontent.com/superhj1987/awesome-scripts/master/self-installer.sh" | bash -s</code></p>

<p><strong>使用：</strong></p>

<ul>
<li><p>显示最繁忙的java线程: -c &lt;要显示的线程栈数> -p &lt;指定的Java Process></p>

<blockquote><p>opscipts show-busy-java-threads [-c] [-p]</p></blockquote></li>
<li><p>使用greys跟踪方法耗时</p>

<blockquote><p>opscripts greys <PID>[@IP:PORT]</p>

<p><strong><em>ga?:</em></strong> trace [class] [method]</p></blockquote></li>
<li><p>显示当前cpu和内存使用状况，包括全局和各个进程的。</p>

<blockquote><p>opscripts show-cpu-and-memory</p></blockquote></li>
<li><p>进入jvm调试交互命令行，包含对java栈、堆、线程、gc等状态的查看</p>

<blockquote><p>opscripts jvm [pid]</p></blockquote></li>
</ul>


<h2>JVM配置示例</h2>

<pre><code>-server #64位机器下默认
-Xms6000M #最小堆大小
-Xmx6000M #最大堆大小
-Xmn500M #新生代大小
-Xss256K #栈大小
-XX:PermSize=500M (JDK7)
-XX:MaxPermSize=500M (JDK7)
-XX:MetaspaceSize=128m  （JDK8）
-XX:MaxMetaspaceSize=512m（JDK8）
-XX:SurvivorRatio=65536
-XX:MaxTenuringThreshold=0 #晋升到老年代需要的存活次数,设置为0时，survivor区失去作用，一次minor gc，eden中存活的对象就会进入老年代，默认是15，使用CMS时默认是4
-Xnoclassgc #不做类的gc
#-XX:+PrintCompilation #输出jit编译情况，慎用
-XX:+TieredCompilation #启用多层编译，jd8默认开启
-XX:CICompilerCount=4 #编译器数目增加
-XX:-UseBiasedLocking #取消偏向锁
-XX:AutoBoxCacheMax=20000 #自动装箱的缓存数量，如int默认缓存为-128~127
-Djava.security.egd=file:/dev/./urandom #替代默认的/dev/random阻塞生成因子
-XX:+AlwaysPreTouch #启动时访问并置零内存页面，大堆时效果比较好
-XX:-UseCounterDecay #禁止JIT调用计数器衰减。默认情况下，每次GC时会对调用计数器进行砍半的操作，导致有些方法一直是个温热，可能永远都达不到C2编译的1万次的阀值。
-XX:ParallelRefProcEnabled=true # 默认为false，并行的处理Reference对象，如WeakReference
-XX:+DisableExplicitGC #此参数会影响使用堆外内存，会造成oom，如果使用NIO,请慎重开启
#-XX:+UseParNewGC #此参数其实在设置了cms后默认会启用，可以不用设置
-XX:+UseConcMarkSweepGC #使用cms垃圾回收器
#-XX:+UseCMSCompactAtFullCollection #是否在fullgc是做一次压缩以整理碎片，默认启用
-XX:CMSFullGCsBeforeCompaction=0 #full gc触发压缩的次数
#-XX:+CMSClassUnloadingEnabled #如果类加载不频繁，也没有大量使用String.intern方法，不建议打开此参数，况且jdk7后string pool已经移动到了堆中。开启此项的话，即使设置了Xnoclassgc也会进行class的gc, 但是某种情况下会造成bug：https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=5&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwjR16Wf6MHQAhWLrVQKHfLdCe4QFgg8MAQ&amp;url=https%3A%2F%2Fblogs.oracle.com%2Fpoonam%2Fentry%2Fjvm_hang_with_cms_collector&amp;usg=AFQjCNFNtkw6jHM-uyz-Wjri3LtAVXWJ8g&amp;sig2=BFxSfHc-AIek18fEhY07mg。
#-XX:+CMSParallelRemarkEnabled #并行标记, 默认开启, 可以不用设置
#-XX:+CMSScavengeBeforeRemark #强制remark之前开始一次minor gc，减少remark的暂停时间，但是在remark之后也将立即开始又一次minor gc
-XX:CMSInitiatingOccupancyFraction=90 #触发full gc的内存使用百分比
-XX:+PrintClassHistogram #打印类统计信息
-XX:+PrintHeapAtGC #打印gc前后的heap信息
-XX:+PrintGCDetails #以下都是为了记录gc日志
-XX:+PrintGCDateStamps
-XX:+PrintGCApplicationStoppedTime #打印清晰的GC停顿时间外，还可以打印其他的停顿时间，比如取消偏向锁，class 被agent redefine，code deoptimization等等
-XX:+PrintTenuringDistribution #打印晋升到老年代的年龄自动调整的情况(并行垃圾回收器启用UseAdaptiveSizePolicy参数的情况下以及其他垃圾回收期也会动态调整，从最开始的MaxTenuringThreshold变成占用当前堆50%的age)
#-XX:+UseAdaptiveSizePolicy # 此参数在并行回收器时是默认开启的会根据应用运行状况做自我调整，如MaxTenuringThreshold、survivor区大小等，其他情况下最好不要开启
#-XX:StringTableSize #字符串常量池表大小(hashtable的buckets的数目)，java 6u30之前无法修改固定为1009，后面的版本默认为60013，可以通过此参数设置
-XX:GCTimeLimit=98 #gc占用时间超过多少抛出OutOfMemoryError
-XX:GCHeapFreeLimit=2 #gc回收后小于百分之多少抛出OutOfMemoryError
-Xloggc:/home/logs/gc.log
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何读取ClassPath下的资源]]></title>
    <link href="http://www.rowkey.me/blog/2017/02/20/read-classpath-resource/"/>
    <updated>2017-02-20T22:21:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/02/20/read-classpath-resource</id>
    <content type="html"><![CDATA[<p>最近在写一些公共组件时，碰到了需要读取classpath下文件的场景。也突然想起其实之前有很多场景牵扯到读取类加载路径下的文件内容、路径，包括非jar包和jar包中的。总结一下，以备后续使用。</p>

<!--more-->


<p>由于获取类路径下的资源文件的都是基于URL的，因此这里需要先讲述一下URL的概念。URL(Uniform Resource Locator)即统一资源定位器，指向互联网资源的指针，是一种具体的资源。其一般的形式，如：</p>

<p><code>scheme:[//host][:port][path][?query][#fragment]</code></p>

<p>scheme包括：http、https、file、jar等。一个例子：file:/User/root/test.jar?time=123431212, 其中：schema为file，path为/root/test.jar, query为time=123431212。</p>

<p>这里需要区分URL和URI。URI, Uniform Resource Identifier，统一资源标识符，用来唯一的标识一个资源。其一般形式：</p>

<p><code>[scheme:][//authority][path][?query][#fragment]</code></p>

<p>其中，authority为[user-info@]host[:port]</p>

<p>可见，URL是一种具体的URI，只不过其scheme是非空的，它不仅仅标识一个资源，也能定位一个资源（即通过url能够访问到这个资源），因此其必须是绝对地址，即使是相对url，其本质也是相对于某绝对url来讲的，也是一个绝对地址。而URI可以是绝对的也可以是相对的，只要能够标识即可。</p>

<p>此外，URL和URI的不同之处还在于前者不提供对标准RFC2396规定的特殊字符的转义，因此需要调用者自己对URL各组成部分进行encode。而java.net.URI则会提供转义功能。这两者可以通过URI.toURL()和URL.toURI()来互相转换。</p>

<p>这里需要指出的是，如果是想直接读取类路径下的资源的内容，那么使用下面的方法是万能的。</p>

<p><code>ClassLoader.getResourceAsStream(String classpathRecourcePath)</code></p>

<p>需要注意的是有时候jar包中的类并非和你应用的类使用的是同一类加载器(写intellij插件的时候就会存在这种问题)，这时候需要选择对应的ClassLoader。</p>

<p>此外，有些场景是需要获取到类路径下的资源路径信息的，可以选用以下三种方法：</p>

<ul>
<li><p>ClassLoader.getResource(String classpathFilePath)`</p>

<p>  此方法的加载过程类似“双亲委派机制”，当父加载器无法获取到资源时，自己才去尝试获取。但需要注意的是以 / 开头的资源是在类加载器目录下的资源，并非指的是当前应用的类加载路径下的资源。如果资源是位于classpath下的不要以 / 开头。</p></li>
<li><p><code>Class&lt;?&gt;.getResource(String classpathFilePath)</code></p>

<p>  此方法最终还是对上面的方法的调用。不同的是，此方法会对传入的路径参数做处理，并且会尝试去获取类加载器。</p>

<ul>
<li>当路径信息不以 / 开头时，获取的是相对于当前类所在路径的相对资源</li>
<li>当路径信息以 / 开头时，则获取的是当前应用类加载路径下的资源</li>
</ul>
</li>
<li><p><code>Class&lt;?&gt;.getProtectionDomain().getCodeBase.getLocation()</code></p>

<p>  此方法获取的是此类所处于的保护域的路径信息，当位于jar包中时，返回的是jar包的路径信息，非jar包则返回的是应用的类加载路径的地址。此方法的一个常见使用场景就是使用嵌入式jetty或者tomcat时对于webappBase的设置。</p></li>
</ul>


<p>还需要提到的一点是：当你想使用File类来处理scheme为file的资源时，可以使用URL的getFile方法获取其path和query信息(URL的getPath方法返回的仅仅包含path部分)。但如果你的资源是位于jar包中的，那么获取到的URL信息是以<strong><em>jar:file</em></strong>开头的，并不能用此方式处理。</p>
]]></content>
  </entry>
  
</feed>
