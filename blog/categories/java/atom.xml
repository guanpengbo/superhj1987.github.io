<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | 后端技术杂谈 | 飒然Hang]]></title>
  <link href="http://www.rowkey.me/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://www.rowkey.me/"/>
  <updated>2018-04-03T19:47:25+08:00</updated>
  <id>http://www.rowkey.me/</id>
  <author>
    <name><![CDATA[飒然Hang]]></name>
    <email><![CDATA[superhj1987@126.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何成为一名合格的Java工程师?]]></title>
    <link href="http://www.rowkey.me/blog/2018/04/01/pje-release/"/>
    <updated>2018-04-01T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2018/04/01/pje-release</id>
    <content type="html"><![CDATA[<p>Java开发一直是当前互联网领域最火热的开发技能之一，Java工程师也一直是需求量非常大的开发职位。那么如何成为一名合格的Java工程师呢？一名合格的Java工程师又应该具有哪些技能呢？针对这些，笔者的新书《Java工程师修炼之道》做了一些经验性的阐述和讲解。</p>

<p><img src="http://www.rowkey.me/post_images/book.png" width="250"/></p>

<!--more-->


<p>写作此书的想法萌生于2015年，主要是在研发招聘过程中，尤其是校招，感受到了目前后端工程师教育的匮乏。对于一个后端工程师的技术体系，先不说学生，不少工作很长时间的人都没有一个清晰的认识。就打算写一本后端工程师技术体系书籍的想法，希望能够给选择后端这个方向的人一些指导，也算是对自己的一个阶段性总结。</p>

<p>2016年初，博文视点“永恒的侠少”（张春雨编辑）找到我，算是正式开始写作此书。历时一年多的时间，于2017年8月份交稿，中间历经许多次修改，《Java工程师修炼之道》终于出版。这本书是自己出的第一本书，所以写作的过程一直是如履薄冰的，一直害怕写成一本没有任何意义的烂书，因此一遍遍地去读，一遍遍地修正，也一遍遍地更新一些知识点，希望最后不要沦为一本鸡肋无味的技术书。</p>

<p>本书主要针对一名合格的Java工程师的必备技能做了大纲性的总结和阐述。内容主要来自于公司内的后端工程师学习计划、自己以前的一些博客文章和自己从业以来积累的知识库。包括了工程化、常用开发框架、数据存储、数据传输、Java编程高级知识、性能优化、安全技术等，基本涵盖了Java工程师需要掌握的绝大部分技能点。</p>

<p>本书可以看作一本Java工程师的入职指南，也可以看作一本串联Java后端技能点的参考手册，同样可以作为创业团队做技术选型的一个参考。通过精心编排的内容，刚入门的Java工程师能够体系化地学习相关开发技能，有经验的Java工程师则能够查漏补缺，进一步加强自身的Java技术体系。</p>

<p>其中的部分内容，会陆续在我的博客和公众号放出。</p>

<p>希望这本书会给想要学习Java后端开发的同学或者还未形成自己技术体系的Java工程师们带来帮助。</p>

<p><strong>购买方式</strong></p>

<ul>
<li>京东：<a href="https://item.jd.com/12325207.html">https://item.jd.com/12325207.html</a></li>
</ul>


<p><img src="//post_images/book_jd.png" alt="" /></p>

<ul>
<li>天猫：<a href="https://detail.tmall.com/item.htm?id=567160971355">https://detail.tmall.com/item.htm?id=567160971355</a></li>
</ul>


<p><img src="//post_images/book_tmall.png" alt="" /></p>

<ul>
<li>微店（签名版）：<a href="https://weidian.com/item.html?itemID=2259146189">https://weidian.com/item.html?itemID=2259146189</a></li>
</ul>


<p><img src="//post_images/book_wd.png" alt="" /></p>

<p><strong>目录</strong></p>

<blockquote><p>第一章 后端技术导言</p>

<p>1.1 后端基础设施</p>

<p>1.2 Java后端技术概览</p>

<p>1.3 如何学习后端技术</p>

<p>第二章 Java项目工程化</p>

<p>2.1 项目构建</p>

<p>2.2 代码版本控制</p>

<p>2.3 代码质量保证</p>

<p>第三章 开发框架</p>

<p>3.1 依赖注入</p>

<p>3.2 对象关系映射</p>

<p>3.3 日志</p>

<p>3.4 Web MVC</p>

<p>第四章 Spring</p>

<p>4.1 Spring核心组件</p>

<p>4.2 Spring数据操作框架</p>

<p>4.3 Spring Boot</p>

<p>4.4 Spring常用组件</p>

<p>4.5 总结</p>

<p>第五章 数据存储</p>

<p>5.1 关系型数据库-MySQL</p>

<p>5.2 非关系型数据库</p>

<p>5.3 缓存</p>

<p>5.4 搜索引擎-Elasticsearch</p>

<p>第六章 数据通信</p>

<p>6.1 RESTful架构风格</p>

<p>6.2 远程过程调用-RPC</p>

<p>6.3 消息中间件</p>

<p>第七章 Java编程进阶</p>

<p>7.1 Java内存管理</p>

<p>7.2 Java网络编程</p>

<p>7.3 Java并发编程</p>

<p>7.4 Java开发利器</p>

<p>7.5 Java新版本特性</p>

<p>7.6 总结</p>

<p>第八章 性能调优</p>

<p>8.1 调优准备</p>

<p>8.2 性能分析</p>

<p>8.3 性能调优</p>

<p>第九章 安全技术</p>

<p>9.1 Java加密</p>

<p>9.2 安全Http - HTTPS</p>

<p>9.3 Web安全</p></blockquote>

<p><strong>推荐</strong></p>

<blockquote><p>2013年，我和本书作者的接触是从基于网易的一个大型互联网应用合作开始的，我见证了从第一行代码到整个系统服务于亿级用户的过程，并且相信这种经历对开发者来说是一笔巨大的财富，其中大量的开发和实战经验都会在本书中得到充分的体现，相信读者能从书中直接领略到丰富的实战知识。在与本书作者的合作过程中，其对Java技术的热爱与追求孜孜不倦，对问题刨根问底，直到理解透彻、灵活应用，这些都令我印象深刻。这些年，我与本书作者一直保持沟通交流、相互学习，他将近十年的实战经验沉底于本书以实现对后端技术的探索、布道，非常值得开发者与近高窗卧听秋。</p>

<p>后端技术涉及内容非常广泛，Java语言也是互联网开发行业使用的主流语言，相信后续也将继续流行很长一段时间，而本书作者也一直从事Java后端开发工作。在本书中作者比较系统地从总体上描述了后端技术相关的理论知识，包括基础设施、网关服务及框架选型等基本原则，然后以实际经验进行示例说明，接着详细梳理了Java的后端技术，相信读者读完本书后会更全面地理解后端技术。互联网的业务建设需要不同角色的开发者共同协作完成，因此，系统工程化是开发者首先要共同遵守的规范或约定，包括代码规范、版本管理和代码质量检查等。</p>

<p>开发框架的选型进一步地为工程化提供了基础，也能加速推进互联网开发，尽管是否重复造轮子是一个恒久的话题，但是没有永远的银弹，只要在合适的时间里根据团队的能力选择合适的技术框架就好。一般来讲，目前常用的框架包括基本的依赖注入、AOP、事务管理、连接池管理、数据操作、日志服务等，在众多的框架中，本书作者选用目前在Java领域使用最广泛的Spring做深入的分析，详细地说明各组件的基础知识、基本原理和实际使用案例，最难得的是把较多开发者遇到的坑都用真实的示例进行了说明，可以帮助开发者快速地跳过这些伤心地带，同时也把最佳实践画龙点睛地带给开发者。</p>

<p>数据存储无疑是所有系统应用中非常重要的一环，应用的场景用例也和数据库的选型有极其重要的关系，开发者选择关系型数据库还是非关系型数据库是需要根据软件成本与人力成本来进行权衡的，比如是选择MySQL、Oracle等开源或商业的数据库。本书重点从数据库的基础知识、索引和表优化等方面以详尽的示例为更好地选择数据库的存储类型提供了更多的知识。</p>

<p>早期的关系型数据库一般能满足数据达到一定规模的企业的需求，而在互联网业务领域，特别是移动互联网领域内的元数据或者日志数据等，达到亿数量级别是很常见的，这时通常使用非关系型数据库，在非关系型数据库里使用非常多的有MongoDB、HBase等分布式数据库系统。作者在自身的企业开发实践中，得到了大量的使用经验和最佳实践。为了加速后端应用，缓存热数据是加速业务、提高业务性能、提升用户体验的重要手段，通过使用本地缓存、远程缓存进行数据加速、数据预热或提高数据的命中率，是开发者在应用开发的过程中常会遇到的场景。</p>

<p>“路漫漫其修远兮，吾将上下而求索”，后端技术每年都在不断发展，所用技术也有变化，近些年Java语言的发展速度不那么快了，但是总体是在不断前进发展的，本书作者带领的团队一直深耕此领域并希望通过本书为技术开发人员带来更多帮助。</p>

<p>&ndash; <strong>尧飘海，网易云基础服务（蜂巢）首席架构师</strong></p></blockquote>

<hr />

<blockquote><p>Hey！新来的读者，为了吸引你的注意力我真是煞费苦心，但最终还是没能写出一句特别吸引眼球的话来，毕竟写序的我不是标题党出生。此刻我真的非常能理解你拿到新书之后那渴望知识的心情，所以你恨不得一个字的“序”也不要看到，直接到达“最有价值”的知识点。但作为一名资深转业码农（对！你没看错，是“转业”，不是“专业”）还是想说一句，你先看完序，5分钟后到达知识的战场，会更稳！</p>

<p>相信你已经在看“序”了，那么我们来说点正经事。</p>

<p>你的知识体系的养成有3个关键阶段：看山是山、看山不是山、看山还是山。本书的适用人群是“看山不是山”的那些人，如果你恰好处于这个阶段，恭喜你！书钱没白花。</p>

<p>Java是一门非常容易入门的语言，初学者经过初期的学习之后基本能掌握DEMO级别的编程应用。相信读者你已经度过了这个阶段，但是Java庞大的体系可能会把你绕晕，又或者你还没看到Java的生态系统有多么复杂。此时，你需要本书。从事程序员这个工作，到比较高阶的时候，其实是不挑语言的，语言只是工具，而你可以在纷繁复杂中游刃有余。但几乎每一位高手都是先深入一个领域，再横向发展的。你可以不用着急后续的横向发展，先坚定自己学习Java的信心！因为，从广泛的应用场景、顶级的开源生态、未来可期的薪水和职位来说，Java都是非常不错的选择。</p>

<p>敲黑板，画重点！下面来解释一下，为什么本书面向的是“看山不是山”的人群。在度过Java的入门期之后，会有一个烦恼，那就是面对Java这么庞大的体系，我们究竟应该学习什么？选择方向，往往比努力更重要！是使用J2SE编写桌面程序？是使用J2ME编写嵌入式应用？还是使用J2EE编写企业级应用？这些是我们那个泛黄的年代特有的烦恼。而现在的烦恼可能是学Android？还是学Java后端？即便大方向你已经十分坚定，而且选择了Java后端编程，但因为复杂的知识体系和Google发布的各种教程文档，眼前看到的已经不再是清晰的山脉，而是一片迷雾。此时，你需要本书，因为它给你指明了努力的方向。</p>

<p>本书的结构、阐述的方式和大部分的“指南”书籍有较大的区别，本书是以笔记和要点的形式进行呈现的，用现在的话说就是捞干货。本书涵盖的知识，是以现代工程实践中的实际案例出发来组织的，所以知识点范围非常广泛，每一个点都对最关键的“Best Practice”简明扼要地进行了说明。你在阅读本书的时候需要一些相关经验，不然无法跟上作者的节奏，建议在有一定的知识准备后再阅读本书，这样你会受益匪浅。从另外一个角度看，在你有了一定的基础积累之后，本书可以帮助你全面地了解一个现代化的最先进的工程实践是怎样的。本书讲述了目前行业中最常用的，经过了实践的工程方案，这将是你快速进阶的最佳指引。</p>

<p>&ndash; <strong>孙建，随身云（中华万年历）联合创始人&amp;CEO</strong></p></blockquote>

<hr />

<blockquote><p>扎实的基础理论知识是内功底子，丰富的实践经验是招式。如本书作者所说，精妙的招式决定了你的武功下限，而深厚的内功底蕴会承载你所能企及的高度。那么，在后端技术栈中，内功与招式之间如何去关联起来，本书作者以其多年的钻研与实践结合心得，通过本书为你一一梳理。</p>

<p>&ndash; <strong>阙杭宁，网易云信CTO</strong></p></blockquote>

<hr />

<blockquote><p>作者是一位技术人,有多年的Java技术积累,是极少数真正热爱技术的人。在随身云架构师的工作让他有机会站在更高的层次进行系统架构的工作,这些实践经验和平时感悟都沉淀在作者的著作和博客中,相信每位Java工程师都能从中获取帮助。</p>

<p>&ndash; <strong>秦绪震，十露盘科技联合创始人，技术负责人</strong></p></blockquote>

<hr />

<blockquote><p>本书作者根据自身多年的JAVA后台开发经验, 提纲挈领的总结JAVA后台开发的各个关键技术点，这些知识点都是一个合格的JAVA工程师必须掌握的技能。它既可以作为新人的技术学习指南，也可以帮助老手对于自己的知识面进行查漏补缺，是一本非常好的技术指南。</p>

<p>&ndash; <strong>饶洵（蜚天），阿里巴巴技术专家</strong></p></blockquote>

<hr />

<blockquote><p>作为一个在后端摸爬多年的Java开发工程师，这本书让我温故而知新。书中介绍的Java相关的知识技能树，不仅涵盖了我个人多年的Java开发技术知识点，也对我所陌生的一些知识点进行了详解，让我突然有一种继续学习的冲动。</p>

<p>一个Java开发工程师的成长，不仅要对Java语言及其特性有深层次的理解，也需要掌握与Java相关的框架、生态及后端开发知识。这本书正是将后端开发工程师需要掌握的技能做了总结，对于提高开发技能有很好的指导作用。</p>

<p>我推荐这本书，对于具有一定Java基础和后端开发知识的读者来说，该书不仅具有仔细学习的价值，同时也是一本可以经常翻阅的工具书籍，对于Java开发工程师的成长和进阶有很大的指导作用。</p>

<p>一本好的技术书籍，不仅要仔细阅读、学习理解，还需要进行较多的实践，将所看所学进行应用，通过不断地实践，加深知识点印象，从而形成永久的记忆和技能。希望各位读者能够通过掌握书中的知识和技能，逐步成长为技术骨干和专家，从而创造更多的技术输出、产品输出，创造更多的财富。</p>

<p>&ndash; <strong>张小川，网易考拉海购架构师，供应链技术主管</strong></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring注解概览]]></title>
    <link href="http://www.rowkey.me/blog/2017/10/28/spring-annotations/"/>
    <updated>2017-10-28T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/10/28/spring-annotations</id>
    <content type="html"><![CDATA[<p>从Java5.0开始，Java开始支持注解。Spring做为Java生态中的领军框架，从2.5版本后也开始支持注解。相比起之前使用xml来配置Spring框架，使用注解提供了更多的控制Spring框架的方式。</p>

<p>现在越来越多的项目也都在使用注解做相关的配置，但Spring的注解非常多，相信很多注解大家都没有使用过。本文就尽量全面地概括介绍一下Spring中常用的注解。</p>

<!--more-->


<h2>一. 核心注解</h2>

<h3>@Required</h3>

<p>此注解用于bean的setter方法上。表示此属性是必须的，必须在配置阶段注入，否则会抛出BeanInitializationExcepion。</p>

<h3>@Autowired</h3>

<p>此注解用于bean的field、setter方法以及构造方法上，显式地声明依赖。根据type来autowiring。</p>

<p>当在field上使用此注解，并且使用属性来传递值时，Spring会自动把值赋给此field。也可以将此注解用于私有属性(不推荐)，如下。</p>

<pre><code>@Component
public class User {
    @Autowired                               
    private Address address;                   
}
</code></pre>

<p>最经常的用法是将此注解用于settter上，这样可以在setter方法中添加自定义代码。如下：</p>

<pre><code>@Component
public class User {
     private Address address;

     @AutoWired
     public setAddress(Address address) {
        // custom code
        this.address=address;
     }
}
</code></pre>

<p>当在构造方法上使用此注解的时候，需要注意的一点就是一个类中只允许有一个构造方法使用此注解。此外，在Spring4.3后，如果一个类仅仅只有一个构造方法，那么即使不使用此注解，那么Spring也会自动注入相关的bean。如下：</p>

<pre><code>@Component
public class User {
    private Address address;

     public User(Address address) {     
        this.address=address;
     }
}

&lt;bean id="user" class="xx.User"/&gt;
</code></pre>

<h3>@Qualifier</h3>

<p>此注解是和@Autowired一起使用的。使用此注解可以让你对注入的过程有更多的控制。</p>

<p>@Qualifier可以被用在单个构造器或者方法的参数上。当上下文有几个相同类型的bean, 使用@Autowired则无法区分要绑定的bean，此时可以使用@Qualifier来指定名称。</p>

<pre><code>@Component
public class User {
    @Autowired
    @Qualifier("address1")
    private Address address;
    ...
}
</code></pre>

<h3>@Configuration</h3>

<p>此注解用在class上来定义bean。其作用和xml配置文件相同，表示此bean是一个Spring配置。此外，此类可以使用@Bean注解来初始化定义bean。</p>

<pre><code>@Configuartion
public class SpringCoreConfig {
    @Bean
    public AdminUser adminUser() {
        AdminUser adminUser = new AdminUser();
        return adminUser;
    }
}
</code></pre>

<h3>@ComponentScan</h3>

<p>此注解一般和@Configuration注解一起使用，指定Spring扫描注解的package。如果没有指定包，那么默认会扫描此配置类所在的package。</p>

<h3>@Lazy</h3>

<p>此注解使用在Spring的组件类上。默认的，Spring中Bean的依赖一开始就被创建和配置。如果想要延迟初始化一个bean，那么可以在此类上使用Lazy注解，表示此bean只有在第一次被使用的时候才会被创建和初始化。此注解也可以使用在被@Configuration注解的类上，表示其中所有被@Bean注解的方法都会延迟初始化。</p>

<h3>@Value</h3>

<p>此注解使用在字段、构造器参数和方法参数上。@Value可以指定属性取值的表达式，支持通过#{}使用SpringEL来取值，也支持使用${}来将属性来源中(Properties文件、本地环境变量、系统属性等)的值注入到bean的属性中。此注解值的注入发生在AutowiredAnnotationBeanPostProcessor类中。</p>

<h2>二. Stereotype注解</h2>

<h3>@Component</h3>

<p>此注解使用在class上来声明一个Spring组件(Bean), 将其加入到应用上下文中。</p>

<h3>@Controller</h3>

<p>此注解使用在class上声明此类是一个Spring controller，是@Component注解的一种具体形式。</p>

<h3>@Service</h3>

<p>此注解使用在class上，声明此类是一个服务类，执行业务逻辑、计算、调用内部api等。是@Component注解的一种具体形式。</p>

<h3>@Repository</h3>

<p>此类使用在class上声明此类用于访问数据库，一般作为DAO的角色。</p>

<p>此注解有自动翻译的特性，例如：当此种component抛出了一个异常，那么会有一个handler来处理此异常，无需使用try-catch块。</p>

<h2>三. Spring Boot注解</h2>

<h3>@EnableAutoConfiguration</h3>

<p>此注解通常被用在主应用class上，告诉Spring Boot自动基于当前包添加Bean、对bean的属性进行设置等。</p>

<h3>@SpringBootApplication</h3>

<p>此注解用在Spring Boot项目的应用主类上（此类需要在base package中）。使用了此注解的类首先会让Spring Boot启动对base package以及其sub-pacakage下的类进行component scan。</p>

<p>此注解同时添加了以下几个注解：</p>

<ul>
<li>@Configuration</li>
<li>@EnableAutoConfiguration</li>
<li>@ComponentScan</li>
</ul>


<h2>四. Spring MVC和REST注解</h2>

<h3>@Controller</h3>

<p>上文已经提到过此注解。</p>

<h3>@RequestMapping</h3>

<p>此注解可以用在class和method上，用来映射web请求到某一个handler类或者handler方法上。当此注解用在Class上时，就创造了一个基础url，其所有的方法上的@RequestMapping都是在此url之上的。</p>

<p>可以使用其method属性来限制请求匹配的http method。</p>

<pre><code>@Controller
@RequestMapping("/users")
public class UserController {
    @RequestMapping(method = RequestMethod.GET)
    public String getUserList() {
        return "users";
    }
}
</code></pre>

<p>此外，Spring4.3之后引入了一系列@RequestMapping的变种。如下：</p>

<ul>
<li>@GetMapping</li>
<li>@PostMapping</li>
<li>@PutMapping</li>
<li>@PatchMapping</li>
<li>@DeleteMapping</li>
</ul>


<p>分别对应了相应method的RequestMapping配置。</p>

<h3>@CookieValue</h3>

<p>此注解用在@RequestMapping声明的方法的参数上，可以把HTTP cookie中相应名称的cookie绑定上去。</p>

<pre><code>    @ReuestMapping("/cookieValue")
    public void getCookieValue(@CookieValue("JSESSIONID") String cookie){

    }
</code></pre>

<p>cookie即http请求中name为JSESSIONID的cookie值。</p>

<h3>@CrossOrigin</h3>

<p>此注解用在class和method上用来支持跨域请求，是Spring 4.2后引入的。</p>

<pre><code>@CrossOrigin(maxAge = 3600)
@RestController
@RequestMapping("/users")
public class AccountController {
    @CrossOrigin(origins = "http://xx.com")
    @RequestMapping("/login")
    public Result userLogin() {
        // ...
    }
}
</code></pre>

<h3>@ExceptionHandler</h3>

<p>此注解使用在方法级别，声明对Exception的处理逻辑。可以指定目标Exception。</p>

<h3>@InitBinder</h3>

<p>此注解使用在方法上，声明对WebDataBinder的初始化(绑定请求参数到JavaBean上的DataBinder)。在controller上使用此注解可以自定义请求参数的绑定。</p>

<h3>@MatrixVariable</h3>

<p>此注解使用在请求handler方法的参数上，Spring可以注入matrix url中相关的值。这里的矩阵变量可以出现在url中的任何地方，变量之间用;分隔。如下：</p>

<pre><code>// GET /pets/42;q=11;r=22
@RequestMapping(value = "/pets/{petId}")
public void findPet(@PathVariable String petId, @MatrixVariable int q) {
    // petId == 42
    // q == 11
}
</code></pre>

<p>需要注意的是默认Spring mvc是不支持矩阵变量的，需要开启。</p>

<pre><code>&lt;mvc:annotation-driven enable-matrix-variables="true" /&gt;
</code></pre>

<p>注解配置则需要如下开启：</p>

<pre><code>@Configuration
public class WebConfig extends WebMvcConfigurerAdapter {

    @Override
    public void configurePathMatch(PathMatchConfigurer configurer) {
        UrlPathHelper urlPathHelper = new UrlPathHelper();
        urlPathHelper.setRemoveSemicolonContent(false);
        configurer.setUrlPathHelper(urlPathHelper);
    }
}
</code></pre>

<h3>@PathVariable</h3>

<p>此注解使用在请求handler方法的参数上。@RequestMapping可以定义动态路径，如:</p>

<pre><code>@RequestMapping("/users/{uid}")
</code></pre>

<p>可以使用@PathVariable将路径中的参数绑定到请求方法参数上。</p>

<pre><code>@RequestMapping("/users/{uid}")
public String execute(@PathVariable("uid") String uid){
}
</code></pre>

<h3>@RequestAttribute</h3>

<p>此注解用在请求handler方法的参数上，用于将web请求中的属性(request attributes，是服务器放入的属性值)绑定到方法参数上。</p>

<h3>@RequestBody</h3>

<p>此注解用在请求handler方法的参数上，用于将http请求的Body映射绑定到此参数上。HttpMessageConverter负责将对象转换为http请求。</p>

<h3>@RequestHeader</h3>

<p>此注解用在请求handler方法的参数上，用于将http请求头部的值绑定到参数上。</p>

<h3>@RequestParam</h3>

<p>此注解用在请求handler方法的参数上，用于将http请求参数的值绑定到参数上。</p>

<h3>@RequestPart</h3>

<p>此注解用在请求handler方法的参数上，用于将文件之类的multipart绑定到参数上。</p>

<h4>@ResponseBody</h4>

<p>此注解用在请求handler方法上。和@RequestBody作用类似，用于将方法的返回对象直接输出到http响应中。</p>

<h3>@ResponseStatus</h3>

<p>此注解用于方法和exception类上，声明此方法或者异常类返回的http状态码。可以在Controller上使用此注解，这样所有的@RequestMapping都会继承。</p>

<h4>@ControllerAdvice</h4>

<p>此注解用于class上。前面说过可以对每一个controller声明一个ExceptionMethod。这里可以使用@ControllerAdvice来声明一个类来统一对所有@RequestMapping方法来做@ExceptionHandler、@InitBinder以及@ModelAttribute处理。</p>

<h3>@RestController</h3>

<p>此注解用于class上，声明此controller返回的不是一个视图而是一个领域对象。其同时引入了@Controller和@ResponseBody两个注解。</p>

<h3>@RestControllerAdvice</h3>

<p>此注解用于class上，同时引入了@ControllerAdvice和@ResponseBody两个注解。</p>

<h3>@SessionAttribute</h3>

<p>此注解用于方法的参数上，用于将session中的属性绑定到参数。</p>

<h3>@SessionAttributes</h3>

<p>此注解用于type级别，用于将JavaBean对象存储到session中。一般和@ModelAttribute注解一起使用。如下：</p>

<pre><code>@ModelAttribute("user")

public PUser getUser() {}

// controller和上面的代码在同一controller中
@Controller
@SeesionAttributes(value = "user", types = {
    User.class
})

public class UserController {}
</code></pre>

<h2>五. 数据访问注解</h2>

<h3>@Transactional</h3>

<p>此注解使用在接口定义、接口中的方法、类定义或者类中的public方法上。需要注意的是此注解并不激活事务行为，它仅仅是一个元数据，会被一些运行时基础设施来消费。</p>

<h2>六. 任务执行、调度注解</h2>

<h3>@Scheduled</h3>

<p>此注解使用在方法上，声明此方法被定时调度。使用了此注解的方法返回类型需要是Void，并且不能接受任何参数。</p>

<pre><code>@Scheduled(fixedDelay=1000)
public void schedule() {

}

@Scheduled(fixedRate=1000)
public void schedulg() { 

}
</code></pre>

<p>第二个与第一个不同之处在于其不会等待上一次的任务执行结束。</p>

<h3>@Async</h3>

<p>此注解使用在方法上，声明此方法会在一个单独的线程中执行。不同于Scheduled注解，此注解可以接受参数。</p>

<p>使用此注解的方法的返回类型可以是Void也可是返回值。但是返回值的类型必须是一个Future。</p>

<h2>七. 测试注解</h2>

<h3>@ContextConfiguration</h3>

<p>此注解使用在Class上，声明测试使用的配置文件，此外，也可以指定加载上下文的类。</p>

<p>此注解一般需要搭配SpringJUnit4ClassRunner使用。</p>

<pre><code>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes = SpringCoreConfig.class)
public class UserServiceTest {

}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java9来了]]></title>
    <link href="http://www.rowkey.me/blog/2017/09/22/java9/"/>
    <updated>2017-09-22T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/09/22/java9</id>
    <content type="html"><![CDATA[<p>2017.9.21，Java9终于正式发布。其带来了诸如模块化、REPL环境、集合工厂方法等一系列有用的新特性。本文列出一些链接，可以通过阅读相关的内容来了解学习Java9。</p>

<h2>官方资料</h2>

<ul>
<li><a href="http://jdk.java.net/9/">JD9下载</a></li>
<li><a href="http://openjdk.java.net/projects/jdk9/">Java9新特性</a></li>
<li><a href="https://docs.oracle.com/javase/9/">Oracle的JDK文档</a></li>
<li><a href="http://mail.openjdk.java.net/pipermail/announce/2017-September/000230.html">Mark Reinhold的JDK9发布声明</a> [Mark Reinhold是Oracle的Java平台首席架构师]</li>
<li><a href="https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-7744EF96-5899-4FB2-B34E-86D49B2E89B6">迁移到Java9的提示</a></li>
<li><a href="https://blogs.oracle.com/theaquarium/java-ee-8-is-final-and-glassfish-50-is-released">JavaEE 8和GlassFish发布</a></li>
</ul>


<h2>第三方资料</h2>

<ul>
<li><a href="https://dzone.com/articles/java-9-besides-modules">Java9中除了模块化的其他新特性介绍</a></li>
<li><a href="https://dzone.com/articles/java-9-and-intellij-idea">Java 9 and IntelliJ IDEA</a></li>
<li>Java9对旧版本应用的支持: <a href="https://dzone.com/articles/yes-you-can-java-9-for-the-legacy-developer">https://dzone.com/articles/yes-you-can-java-9-for-the-legacy-developer</a>、<a href="https://dzone.com/articles/the-legacy-developers-guide-to-java-9">https://dzone.com/articles/the-legacy-developers-guide-to-java-9</a></li>
<li>Java9模块化开发：<a href="https://dzone.com/articles/java-9-modularity-jigsaw">第一部分</a>、<a href="https://dzone.com/articles/java-9-modular-development-part-2">第二部分</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译]Java中9个处理Exception的最佳实践]]></title>
    <link href="http://www.rowkey.me/blog/2017/09/17/java-exception/"/>
    <updated>2017-09-17T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/09/17/java-exception</id>
    <content type="html"><![CDATA[<p>在Java中处理异常并不是一个简单的事情。不仅仅初学者很难理解，即使一些有经验的开发者也需要花费很多时间来思考如何处理异常，包括需要处理哪些异常，怎样处理等等。这也是绝大多数开发团队都会制定一些规则来规范对异常的处理的原因。而团队之间的这些规范往往是截然不同的。</p>

<p>本文给出几个被很多团队使用的异常处理最佳实践。</p>

<!--more-->


<h2>1. 在Finally块中清理资源或者使用try-with-resource语句</h2>

<p>当使用类似InputStream这种需要使用后关闭的资源时，一个常见的错误就是在try块的最后关闭资源。</p>

<pre><code>public void doNotCloseResourceInTry() {
    FileInputStream inputStream = null;
    try {
        File file = new File("./tmp.txt");
        inputStream = new FileInputStream(file);
        // use the inputStream to read a file
        // do NOT do this
        inputStream.close();
    } catch (FileNotFoundException e) {
        log.error(e);
    } catch (IOException e) {
        log.error(e);
    }
}
</code></pre>

<p>上述代码在没有任何exception的时候运行是没有问题的。但是当try块中的语句抛出异常或者自己实现的代码抛出异常，那么就不会执行最后的关闭语句，从而资源也无法释放。</p>

<p>合理的做法则是将所有清理的代码都放到finally块中或者使用try-with-resource语句。</p>

<pre><code>public void closeResourceInFinally() {
    FileInputStream inputStream = null;
    try {
        File file = new File("./tmp.txt");
        inputStream = new FileInputStream(file);
        // use the inputStream to read a file
    } catch (FileNotFoundException e) {
        log.error(e);
    } finally {
        if (inputStream != null) {
            try {
                inputStream.close();
            } catch (IOException e) {
                log.error(e);
            }
        }
    }
}

public void automaticallyCloseResource() {
    File file = new File("./tmp.txt");
    try (FileInputStream inputStream = new FileInputStream(file);) {
        // use the inputStream to read a file
    } catch (FileNotFoundException e) {
        log.error(e);
    } catch (IOException e) {
        log.error(e);
    }
}
</code></pre>

<h2>2. 指定具体的异常</h2>

<p>尽可能的使用最具体的异常来声明方法，这样才能使得代码更容易理解。</p>

<pre><code>public void doNotDoThis() throws Exception {
    ...
}
public void doThis() throws NumberFormatException {
    ...
}
</code></pre>

<p>如上，NumberFormatException字面上即可以看出是数字格式化错误。</p>

<h2>3. 对异常进行文档说明</h2>

<p>当在方法上声明抛出异常时，也需要进行文档说明。和前面的一点一样，都是为了给调用者提供尽可能多的信息，从而可以更好地避免/处理异常。</p>

<p>在Javadoc中加入throws声明，并且描述抛出异常的场景。</p>

<pre><code>/**
 * This method does something extremely useful ...
 *
 * @param input
 * @throws MyBusinessException if ... happens
 */
public void doSomething(String input) throws MyBusinessException {
    ...
}
</code></pre>

<h2>4. 抛出异常的时候包含描述信息</h2>

<p>在抛出异常时，需要尽可能精确地描述问题和相关信息，这样无论是打印到日志中还是监控工具中，都能够更容易被人阅读，从而可以更好地定位具体错误信息、错误的严重程度等。</p>

<p>但这里并不是说要对错误信息长篇大论，因为本来Exception的类名就能够反映错误的原因，因此只需要用一到两句话描述即可。</p>

<pre><code>try {
    new Long("xyz");
} catch (NumberFormatException e) {
    log.error(e);
}
</code></pre>

<p>NumberFormatException即告诉了这个异常是格式化错误，异常的额外信息只需要提供这个错误字符串即可。当异常的名称不够明显的时候，则需要提供尽可能具体的错误信息。</p>

<h2>5. 首先捕获最具体的异常</h2>

<p>现在很多IDE都能智能提示这个最佳实践，当你试图首先捕获最笼统的异常时，会提示<strong><em>不能达到的代码</em></strong>。</p>

<p>当有多个catch块中，按照捕获顺序只有第一个匹配到的catch块才能执行。因此，如果先捕获IllegalArgumentException，那么则无法运行到对NumberFormatException的捕获。</p>

<pre><code>public void catchMostSpecificExceptionFirst() {
    try {
        doSomething("A message");
    } catch (NumberFormatException e) {
        log.error(e);
    } catch (IllegalArgumentException e) {
        log.error(e)
    }
}
</code></pre>

<h2>6. 不要捕获Throwable</h2>

<p>Throwable是所有异常和错误的父类。你可以在catch语句中捕获，但是永远不要这么做。</p>

<p>如果catch了throwable，那么不仅仅会捕获所有exception，还会捕获error。而error是表明无法恢复的jvm错误。因此除非绝对肯定能够处理或者被要求处理error，不要捕获throwable。</p>

<pre><code>public void doNotCatchThrowable() {
    try {
        // do something
    } catch (Throwable t) {
        // don't do this!
    }
}
</code></pre>

<h2>7. 不要忽略异常</h2>

<p>很多时候，开发者很有自信不会抛出异常，因此写了一个catch块，但是没有做任何处理或者记录日志。</p>

<pre><code>
public void doNotIgnoreExceptions() {
    try {
        // do something
    } catch (NumberFormatException e) {
        // this will never happen
    }
}
</code></pre>

<p>但现实是经常会出现无法预料的异常或者无法确定这里的代码未来是不是会改动(删除了阻止异常抛出的代码)，而此时由于异常被捕获，使得无法拿到足够的错误信息来定位问题。</p>

<p>合理的做法是至少要记录异常的信息。</p>

<pre><code>public void logAnException() {
    try {
        // do something
    } catch (NumberFormatException e) {
        log.error("This should never happen: " + e);
    }
}
</code></pre>

<h2>8. 不要记录并抛出异常</h2>

<p>可以发现很多代码甚至类库中都会有捕获异常、记录日志并再次抛出的逻辑。如下：</p>

<pre><code>try {
    new Long("xyz");
} catch (NumberFormatException e) {
    log.error(e);
    throw e;
}
</code></pre>

<p>这个处理逻辑看着是合理的。但这经常会给同一个异常输出多条日志。如下：</p>

<pre><code>17:44:28,945 ERROR TestExceptionHandling:65 - java.lang.NumberFormatException: For input string: "xyz"
Exception in thread "main" java.lang.NumberFormatException: For input string: "xyz"
at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
at java.lang.Long.parseLong(Long.java:589)
at java.lang.Long.(Long.java:965)
at com.stackify.example.TestExceptionHandling.logAndThrowException(TestExceptionHandling.java:63)
at com.stackify.example.TestExceptionHandling.main(TestExceptionHandling.java:58)
</code></pre>

<p>如上所示，后面的日志也没有附加更有用的信息。如果想要提供更加有用的信息，那么可以将异常包装为自定义异常。</p>

<pre><code>
public void wrapException(String input) throws MyBusinessException {
    try {
        // do something
    } catch (NumberFormatException e) {
        throw new MyBusinessException("A message that describes the error.", e);
    }
}
</code></pre>

<p>因此，仅仅当想要处理异常时才去捕获，否则只需要在方法签名中声明让调用者去处理。</p>

<h2>9. 包装异常时不要抛弃原始的异常</h2>

<p>捕获标准异常并包装为自定义异常是一个很常见的做法。这样可以添加更为具体的异常信息并能够做针对的异常处理。</p>

<p>需要注意的是，包装异常时，一定要把原始的异常设置为cause(Exception有构造方法可以传入cause)。否则，丢失了原始的异常信息会让错误的分析变得困难。</p>

<pre><code>public void wrapException(String input) throws MyBusinessException {
    try {
        // do something
    } catch (NumberFormatException e) {
        throw new MyBusinessException("A message that describes the error.", e);
    }
}
</code></pre>

<h2>总结</h2>

<p>综上可知，当抛出或者捕获异常时，有很多不一样的东西需要考虑。其中的许多点都是为了提升代码的可阅读性或者api的可用性。</p>

<p>异常不仅仅是一个错误控制机制，也是一个沟通媒介，因此与你的协作者讨论这些最佳实践并制定一些规范能够让每个人都理解相关的通用概念并且能够按照同样的方式使用它们。</p>

<p>原文链接: <a href="https://dzone.com/articles/9-best-practices-to-handle-exceptions-in-java">https://dzone.com/articles/9-best-practices-to-handle-exceptions-in-java</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译]Java中的十个"单行代码编程"(One Liner)]]></title>
    <link href="http://www.rowkey.me/blog/2017/09/09/java-oneliners/"/>
    <updated>2017-09-09T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/09/09/java-oneliners</id>
    <content type="html"><![CDATA[<p>本文列举了十个使用一行代码即可独立完成(不依赖其他代码)的业务逻辑，主要依赖的是Java8中的Lambda和Stream等新特性以及try-with-resources、JAXB等。</p>

<!--more-->


<ol>
<li><p>对列表/数组中的每个元素都乘以2</p>

<pre><code class="`"> // Range是半开区间
 int[] ia = range(1, 10).map(i -&gt; i * 2).toArray();
 List&lt;Integer&gt; result = range(1, 10).map(i -&gt; i * 2).boxed().collect(toList());
</code></pre></li>
<li><p>计算集合/数组中的数字之和</p>

<pre><code class="`"> range(1, 1000).sum();
 range(1, 1000).reduce(0, Integer::sum);
 Stream.iterate(0, i -&gt; i + 1).limit(1000).reduce(0, Integer::sum);
 IntStream.iterate(0, i -&gt; i + 1).limit(1000).reduce(0, Integer::sum);
</code></pre></li>
<li><p>验证字符串是否包含集合中的某一字符串</p>

<pre><code class="`">final List&lt;String&gt; keywords = Arrays.asList("brown", "fox", "dog", "pangram");
final String tweet = "The quick brown fox jumps over a lazy dog. #pangram http://www.rinkworks.com/words/pangrams.shtml";

keywords.stream().anyMatch(tweet::contains);
keywords.stream().reduce(false, (b, keyword) -&gt; b || tweet.contains(keyword), (l, r) -&gt; l || r);
</code></pre></li>
<li><p>读取文件内容</p>

<blockquote><p>原作者认为try with resources也是一种单行代码编程。</p></blockquote>

<pre><code class="`"> try (BufferedReader reader = new BufferedReader(new FileReader("data.txt"))) {
   String fileText = reader.lines().reduce("", String::concat);
 }

 try (BufferedReader reader = new BufferedReader(new FileReader("data.txt"))) {
   List&lt;String&gt; fileLines = reader.lines().collect(toCollection(LinkedList&lt;String&gt;::new));
 }

 try (Stream&lt;String&gt; lines = Files.lines(new File("data.txt").toPath(), Charset.defaultCharset())) {
   List&lt;String&gt; fileLines = lines.collect(toCollection(LinkedList&lt;String&gt;::new));
 }
</code></pre></li>
<li><p>输出歌曲《Happy Birthday to You!》 - 根据集合中不同的元素输出不同的字符串</p>

<pre><code class="`"> range(1, 5).boxed().map(i -&gt; { out.print("Happy Birthday "); if (i == 3) return "dear NAME"; else return "to You"; }).forEach(out::println);
</code></pre></li>
<li><p>过滤并分组集合中的数字</p>

<pre><code class="`"> Map&lt;String, List&lt;Integer&gt;&gt; result = Stream.of(49, 58, 76, 82, 88, 90).collect(groupingBy(forPredicate(i -&gt; i &gt; 60, "passed", "failed")));
</code></pre></li>
<li><p>获取并解析xml协议的Web Service</p>

<pre><code class="`">FeedType feed = JAXB.unmarshal(new URL("http://search.twitter.com/search.atom?&amp;q=java8"), FeedType.class);
JAXB.marshal(feed, System.out);
</code></pre></li>
<li><p>获得集合中最小/最大的数字</p>

<pre><code class="`"> int min = Stream.of(14, 35, -7, 46, 98).reduce(Integer::min).get();
 min = Stream.of(14, 35, -7, 46, 98).min(Integer::compare).get();
 min = Stream.of(14, 35, -7, 46, 98).mapToInt(Integer::new).min();

 int max = Stream.of(14, 35, -7, 46, 98).reduce(Integer::max).get();
 max = Stream.of(14, 35, -7, 46, 98).max(Integer::compare).get();
 max = Stream.of(14, 35, -7, 46, 98).mapToInt(Integer::new).max();
</code></pre></li>
<li><p>并行处理</p>

<pre><code class="`"> long result = dataList.parallelStream().mapToInt(line -&gt; processItem(line)).sum();
</code></pre></li>
<li><p>集合上的各种查询(LINQ in Java)</p>

<pre><code>List&lt;Album&gt; albums = Arrays.asList(unapologetic, tailgates, red);

//筛选出至少有一个track评级4分以上的专辑，并按照名称排序后打印出来。
albums.stream()
  .filter(a -&gt; a.tracks.stream().anyMatch(t -&gt; (t.rating &gt;= 4)))
  .sorted(comparing(album -&gt; album.name))
  .forEach(album -&gt; System.out.println(album.name));

//合并所有专辑的track
List&lt;Track&gt; allTracks = albums.stream()
  .flatMap(album -&gt; album.tracks.stream())
  .collect(toList());

//根据track的评分对所有track分组
Map&lt;Integer, List&lt;Track&gt;&gt; tracksByRating = allTracks.stream()
  .collect(groupingBy(Track::getRating));
</code></pre></li>
</ol>


<p>原文: <a href="https://github.com/aruld/java-oneliners/wiki">https://github.com/aruld/java-oneliners/wiki</a></p>

<hr />

<p><strong><em>补充 by 飒然Hang</em></strong>: 上述的<strong>单行代码编程</strong>确实能够减少代码的字符数，也经常能够给人以高大上的感觉，但是在Java编程中字符其实是非常廉价的，尤其是现在诸如Intellij等IDE已经具有自动补充/生成代码、重构等智能化功能。如果仅仅是为了减少字符的数量，那么没必要刻意去追求<strong>单行代码编程</strong>。让你的代码易于阅读才是最关键的。</p>
]]></content>
  </entry>
  
</feed>
