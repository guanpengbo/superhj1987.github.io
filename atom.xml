<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[后端技术杂谈 | 飒然Hang]]></title>
  <link href="http://www.rowkey.me/atom.xml" rel="self"/>
  <link href="http://www.rowkey.me/"/>
  <updated>2018-01-04T16:47:57+08:00</updated>
  <id>http://www.rowkey.me/</id>
  <author>
    <name><![CDATA[飒然Hang]]></name>
    <email><![CDATA[superhj1987@126.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何快速尝出毒酒？]]></title>
    <link href="http://www.rowkey.me/blog/2018/01/04/king-rec-pois-wine/"/>
    <updated>2018-01-04T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2018/01/04/king-rec-pois-wine</id>
    <content type="html"><![CDATA[<h2>问题</h2>

<p>国王有一百桶酒，比自己的生命还重要。结果有一天其中一桶被投了慢性毒药，喝了以后半个小时以后就会死掉。国王大怒，命令玩忽职守的侍卫去试毒。酒不能被混合，一个侍卫可以喝多桶酒，一桶酒也可以由多个侍卫喝，怎么样才能用最少的侍卫、在最短的时间知道哪桶是毒酒。侍卫可以理解为线程，即怎么样用最少的线程用最快的速度完成这个工作。</p>

<h2>方案</h2>

<p>此问题是我在面试是经常用的一道题目，主要考察的是候选人能不能以计算机的思维考虑问题。</p>

<p>最简单的方案肯定是找100个人，每个人试一桶酒，那么用时30分钟，就可以判断出哪一桶就有毒。</p>

<p>再进一步的，可以使用分段法，把酒分成n份，先找n个侍卫试酒，可以定位出哪一段的酒有毒，再接着分段试酒。但这种方案，分段数目越少，试出毒酒的平均耗时就越长。</p>

<p>如果用计算机的思维来分析这个问题，那么首先考虑如何存储这100桶酒。100桶酒可以用二进制7个bit来表示（2<sup>7</sup>>100）。对应那一桶毒酒，其二进制表示中为1的位置如果能够可以定位出来，就可以定位出此桶毒酒。可以找7个侍卫编号1-7。对于每一桶酒的二进制表示（不足七位前面用0表示），从第一位到第七位，如果是1，则对应编号的侍卫喝此桶酒。这样，每个侍卫喝掉对应的酒。30分钟后，侍卫按照编号1-7，死掉的置为1，活着的置为0，如此，侍卫的一个序列如0000111就表示第七桶酒为毒酒。</p>

<h2>总结</h2>

<p>上述最后一种方案提现了在计算机中使用bit来解决问题的思路。当需要节省存储的时候，使用bit来做经常会有出其不易的效果。就比如最近很火的电影《天才枪手》中，主角们记忆选择题的答案A、B、C、D，完全可以使用位编码来表示四种答案:00-A 01-B 10-C 11-D，四个bit转换为一个十进制数字，如此就可以节省一半的存储，记忆起来也会简单很多。此外，我们处理大数据去重/计数使用的Bitmap、BloomFilter，也都是一种使用bit节省存储的思路。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[技术琐话2018-01-01]]></title>
    <link href="http://www.rowkey.me/blog/2018/01/01/tech-talk/"/>
    <updated>2018-01-01T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2018/01/01/tech-talk</id>
    <content type="html"><![CDATA[<blockquote><p>日常的工作学习中，经常会看到好的知识点，对自己有提示的一句话，或者是自己突然想通了一件事情。决定以博客的形式记录下来，以“技术琐话”作为主题。</p>

<p>2018年以“技术琐话”开篇，主要是整理了一下自己以前一些零散的知识点。</p></blockquote>

<h2>技术感悟</h2>

<ul>
<li><p>阅读各种技术的使用/说明/示例/原理文档时，能不能快速吸收为自己的知识？能不能注意到细节关键点？是一个开发工程师优不优秀，能不能比别人更突出、更快成长起来的一个非常重要的地方。</p></li>
<li><p>你东西学得广了，别人就会攻击你不够深入；你东西学得够深了，别人就会攻击你知识面不广；你专精在技术时，别人就会说你管理不好；你花心力好好做管理之后，别人就会说你技术没有跟上；你研究方法论时，别人就会说你很虚；你专心做项目时，别人就会说你没有提炼方法，没有系统。&hellip; 想挑你毛病，总有办法。但你自己知道自己在干什么最重要，那些你的「缺点」其实可能不是缺点，而是一件事物的另一面。你选择这一面，自然会缺另一面。这是取舍点，不是优缺点。(from 微博<strong>@蔡学镛</strong>)</p></li>
<li><p>来自硅谷的启示</p>

<p>  <img src="http://www.rowkey.me/images/blog_images/silicon-tech.jpg" alt="" /></p></li>
</ul>


<h2>技术点</h2>

<ul>
<li><p>在写Java代码的时候，如果匿名内部类里面传递变量，变量必须声明为final，而在Java8中，可以不用写这个final了，因为Java8引入了Effectively final 功能，由系统默认添加。<a href="http://t.cn/R5QgeVW">What is Effectively Final variable of Java 8</a></p></li>
<li><p>将Nginx中的一个配置指令proxyinterceptorerrors设置为true，可以捕获后端服务器返回的错误码进行处理，从而可以使用nginx自己的错误显示页面。 ​​​​</p></li>
<li><p>在Servlet开发中，request.setCharacterEncoding必须在所有filter最开始执行，否则只要调用过request相关方法去获取其参数等，再去设置编码是无效的。</p></li>
<li><p>Java中File类的listFiles和list方法最终调用的是FileSystem的本地接口，返回的文件列表顺序是没有保证的。Spring中的san某一basepackage下的类就是使用的此方法，因此加载的bean的顺序也是无法保证的。这一点需要特别注意。 ​​​​​​</p></li>
<li><p>Tomcat各个版本特性对比图</p>

<p>  <img src="http://www.rowkey.me/images/blog_images/tc.png" alt="" /></p></li>
<li><p>Java集合类对比图表</p>

<p>  <img src="http://www.rowkey.me/images/blog_images/java-collections.jpg" alt="" /></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何实现延时触发/定时器]]></title>
    <link href="http://www.rowkey.me/blog/2017/12/28/delay-trigger/"/>
    <updated>2017-12-28T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/12/28/delay-trigger</id>
    <content type="html"><![CDATA[<h2>问题</h2>

<p>微信公众平台后台有一个功能即定时群发消息，如明晚的20:00群发一条图文消息。那么这种延时触发的逻辑如何实现呢？</p>

<!--more-->


<h2>方案一</h2>

<p><strong>每隔一定的时间扫描所有超时的事件</strong></p>

<p>这是最容易想到的一种方案。此方案最关键的两点是轮训的频率以及如何高效地获取超时任务。</p>

<ul>
<li>如果可以允许一秒左右的误差，每隔一秒轮训一次即可。</li>
<li>采用红黑树或者最小堆存储触发任务，按照触发时间戳排序。如此，每次扫描能够很快地获取超时的任务。实践中，一个很简单的方案就是使用Redis的SortedSet存储触发任务，这样只需要使用zrangeByScore获取超时的任务，再使用zremrangeByScore即可删除已经触发的任务。</li>
</ul>


<p>此种方案的缺点在于即使频率到达一秒，也可能会有一秒的误差。此外，轮训的方式在很多情况下并没有可触发的任务，会浪费资源。</p>

<h2>方案二</h2>

<p><strong>阻塞线程等待时间超时</strong></p>

<p>此方案思路来自于Nginx中定时器的实现（和Java中的DelayQueue原理类似）。任务的存储和上面的方案类似，采用最小堆或者红黑树即可。然后选择最近要被触发的任务的时间距离作为阻塞调用epoll_wait的超时（也可以使用其他可以设置超时的阻塞调用）。阻塞超时后，依次获取最小触发时间戳的任务，超时则执行。</p>

<p>此种方案的最大优点在于不会有空的任务检查周期。</p>

<h2>方案三</h2>

<p><strong>采用环形队列</strong></p>

<p>此方案详细可以见58沈剑的文章<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959961&amp;idx=1&amp;sn=afec02c8dc6db9445ce40821b5336736&amp;chksm=bd2d07458a5a8e5314560620c240b1c4cf3bbf801fc0ab524bd5e8aa8b8ef036cf755d7eb0f6">《1分钟实现“延迟消息”功能》</a>。大体的思路如下：</p>

<p>采用环形队列，3600个slot，每隔1秒扫描一个slot，检查当前slot里面的所有任务，检查其cycleNum是否为0, 为0则触发，否则cycleNum-1。添加定时事件时，根据扫描指针的当前slot的index和事件触发的时间，计算cycleNum和要放入的slot。</p>

<p>此种方案的本质是<strong>栅格化与预计算</strong>，相比起前两种方案，大大提升了每次获取可触发任务的效率。但同样存在每次查询任务有可能做无用功的问题。此外，需要特别处理添加任务和扫描任务的临界点的问题，否则也可能会有时间上的误差。</p>

<p><strong>PS: 这个方案原理是和时间轮(Netty中的HashedWheelTimer)一样的，多谢@imangry提示</strong></p>

<h2>方案四</h2>

<p><strong>延时消息队列</strong></p>

<p>目前，RabbitMQ、RocketMQ都支持延时消息队列，直接使用即可。但这种依赖消息队列的方案，如果要取消定时任务，则无法实现。其中，RabbitMQ的实现思路是基于TTL的，详细可见：<a href="http://www.cnblogs.com/haoxinyue/p/6613706.html">http://www.cnblogs.com/haoxinyue/p/6613706.html</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[技术琐话2017-11-26]]></title>
    <link href="http://www.rowkey.me/blog/2017/11/26/tech-talk/"/>
    <updated>2017-11-26T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/11/26/tech-talk</id>
    <content type="html"><![CDATA[<blockquote><p>日常的工作学习中，经常会看到好的知识点，对自己有提示的一句话，或者是自己突然想通了一件事情。决定以博客的形式记录下来，以“技术琐话”作为主题。</p></blockquote>

<ul>
<li><p>The interesting thing about performance is that if you analyze most programs, you find that they waste most of their time in a small fraction of code. If you optimize all the code equally, you end up with 90 percent of the optimizations wasted, because you are optimizing code that isn&rsquo;t run much. The time spent making the program fast, the time lost because of lack of clarity, is all wasted time.《重构》一书的一段话，也是不要过早优化的意思，即在不确定这段代码真的会被频繁调用、真的是系统的性能瓶颈之前，没必要花时间优化此处的性能。</p></li>
<li><p>这句话揭示了成为技术专家的一个关键特质: 理解一个系统应该如何工作并不能使人成为专家，只能靠调查系统为何不能正常工作才行。（From SRE ，by Brian Redman）</p></li>
<li><p>技术书籍的出版门槛越来越低，该如何识别是否是一本烂书呢？在我自己看来，英文书籍质量远远好于中文书籍，翻译的版本一般来说质量也不错，不过作为一个互联网从业的技术人员，能够直接阅读英文原版是最好不过的。而对于中文书籍，如果是以公司名义或者书的序多于3篇，是一本烂书的概率非常大，写推荐语、写序的人名头越大，并不代表这本书的质量有多好。此外，现在某sdn专家真的是门槛低到不行，挂这个名头出的书更要慎重选择。对于InfoQ推荐的书，倒是可以值得一读。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring注解概览]]></title>
    <link href="http://www.rowkey.me/blog/2017/10/28/spring-annotations/"/>
    <updated>2017-10-28T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/10/28/spring-annotations</id>
    <content type="html"><![CDATA[<p>从Java5.0开始，Java开始支持注解。Spring做为Java生态中的领军框架，从2.5版本后也开始支持注解。相比起之前使用xml来配置Spring框架，使用注解提供了更多的控制Spring框架的方式。</p>

<p>现在越来越多的项目也都在使用注解做相关的配置，但Spring的注解非常多，相信很多注解大家都没有使用过。本文就尽量全面地概括介绍一下Spring中常用的注解。</p>

<!--more-->


<h2>一. 核心注解</h2>

<h3>@Required</h3>

<p>此注解用于bean的setter方法上。表示此属性是必须的，必须在配置阶段注入，否则会抛出BeanInitializationExcepion。</p>

<h3>@Autowired</h3>

<p>此注解用于bean的field、setter方法以及构造方法上，显式地声明依赖。根据type来autowiring。</p>

<p>当在field上使用此注解，并且使用属性来传递值时，Spring会自动把值赋给此field。也可以将此注解用于私有属性(不推荐)，如下。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Component
</span><span class='line'>public class User {
</span><span class='line'>    @Autowired                               
</span><span class='line'>    private Address address;                   
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>最经常的用法是将此注解用于settter上，这样可以在setter方法中添加自定义代码。如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Component
</span><span class='line'>public class User {
</span><span class='line'>     private Address address;
</span><span class='line'>    
</span><span class='line'>     @AutoWired
</span><span class='line'>   public setAddress(Address address) {
</span><span class='line'>      // custom code
</span><span class='line'>      this.address=address;
</span><span class='line'>   }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>当在构造方法上使用此注解的时候，需要注意的一点就是一个类中只允许有一个构造方法使用此注解。此外，在Spring4.3后，如果一个类仅仅只有一个构造方法，那么即使不使用此注解，那么Spring也会自动注入相关的bean。如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Component
</span><span class='line'>public class User {
</span><span class='line'>    private Address address;
</span><span class='line'>    
</span><span class='line'>     public User(Address address) {       
</span><span class='line'>        this.address=address;
</span><span class='line'>     }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>&lt;bean id="user" class="xx.User"/&gt;</span></code></pre></td></tr></table></div></figure>


<h3>@Qualifier</h3>

<p>此注解是和@Autowired一起使用的。使用此注解可以让你对注入的过程有更多的控制。</p>

<p>@Qualifier可以被用在单个构造器或者方法的参数上。当上下文有几个相同类型的bean, 使用@Autowired则无法区分要绑定的bean，此时可以使用@Qualifier来指定名称。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Component
</span><span class='line'>public class User {
</span><span class='line'>    @Autowired
</span><span class='line'>    @Qualifier("address1")
</span><span class='line'>    private Address address;
</span><span class='line'>    ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>@Configuration</h3>

<p>此注解用在class上来定义bean。其作用和xml配置文件相同，表示此bean是一个Spring配置。此外，此类可以使用@Bean注解来初始化定义bean。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Configuartion
</span><span class='line'>public class SpringCoreConfig {
</span><span class='line'>    @Bean
</span><span class='line'>    public AdminUser adminUser() {
</span><span class='line'>        AdminUser adminUser = new AdminUser();
</span><span class='line'>        return adminUser;
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>@ComponentScan</h3>

<p>此注解一般和@Configuration注解一起使用，指定Spring扫描注解的package。如果没有指定包，那么默认会扫描此配置类所在的package。</p>

<h3>@Lazy</h3>

<p>此注解使用在Spring的组件类上。默认的，Spring中Bean的依赖一开始就被创建和配置。如果想要延迟初始化一个bean，那么可以在此类上使用Lazy注解，表示此bean只有在第一次被使用的时候才会被创建和初始化。此注解也可以使用在被@Configuration注解的类上，表示其中所有被@Bean注解的方法都会延迟初始化。</p>

<h3>@Value</h3>

<p>此注解使用在字段、构造器参数和方法参数上。@Value可以指定属性取值的表达式，支持通过#{}使用SpringEL来取值，也支持使用${}来将属性来源中(Properties文件、本地环境变量、系统属性等)的值注入到bean的属性中。此注解值的注入发生在AutowiredAnnotationBeanPostProcessor类中。</p>

<h2>二. Stereotype注解</h2>

<h3>@Component</h3>

<p>此注解使用在class上来声明一个Spring组件(Bean), 将其加入到应用上下文中。</p>

<h3>@Controller</h3>

<p>此注解使用在class上声明此类是一个Spring controller，是@Component注解的一种具体形式。</p>

<h3>@Service</h3>

<p>此注解使用在class上，声明此类是一个服务类，执行业务逻辑、计算、调用内部api等。是@Component注解的一种具体形式。</p>

<h3>@Repository</h3>

<p>此类使用在class上声明此类用于访问数据库，一般作为DAO的角色。</p>

<p>此注解有自动翻译的特性，例如：当此种component抛出了一个异常，那么会有一个handler来处理此异常，无需使用try-catch块。</p>

<h2>三. Spring Boot注解</h2>

<h3>@EnableAutoConfiguration</h3>

<p>此注解通常被用在主应用class上，告诉Spring Boot自动基于当前包添加Bean、对bean的属性进行设置等。</p>

<h3>@SpringBootApplication</h3>

<p>此注解用在Spring Boot项目的应用主类上（此类需要在base package中）。使用了此注解的类首先会让Spring Boot启动对base package以及其sub-pacakage下的类进行component scan。</p>

<p>此注解同时添加了以下几个注解：</p>

<ul>
<li>@Configuration</li>
<li>@EnableAutoConfiguration</li>
<li>@ComponentScan</li>
</ul>


<h2>四. Spring MVC和REST注解</h2>

<h3>@Controller</h3>

<p>上文已经提到过此注解。</p>

<h3>@RequestMapping</h3>

<p>此注解可以用在class和method上，用来映射web请求到某一个handler类或者handler方法上。当此注解用在Class上时，就创造了一个基础url，其所有的方法上的@RequestMapping都是在此url之上的。</p>

<p>可以使用其method属性来限制请求匹配的http method。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Controller
</span><span class='line'>@RequestMapping("/users")
</span><span class='line'>public class UserController {
</span><span class='line'>    @RequestMapping(method = RequestMethod.GET)
</span><span class='line'>    public String getUserList() {
</span><span class='line'>        return "users";
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>此外，Spring4.3之后引入了一系列@RequestMapping的变种。如下：</p>

<ul>
<li>@GetMapping</li>
<li>@PostMapping</li>
<li>@PutMapping</li>
<li>@PatchMapping</li>
<li>@DeleteMapping</li>
</ul>


<p>分别对应了相应method的RequestMapping配置。</p>

<h3>@CookieValue</h3>

<p>此注解用在@RequestMapping声明的方法的参数上，可以把HTTP cookie中相应名称的cookie绑定上去。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@ReuestMapping("/cookieValue")
</span><span class='line'>      public void getCookieValue(@CookieValue("JSESSIONID") String cookie){
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>cookie即http请求中name为JSESSIONID的cookie值。</p>

<h3>@CrossOrigin</h3>

<p>此注解用在class和method上用来支持跨域请求，是Spring 4.2后引入的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@CrossOrigin(maxAge = 3600)
</span><span class='line'>@RestController
</span><span class='line'>@RequestMapping("/users")
</span><span class='line'>public class AccountController {
</span><span class='line'>    @CrossOrigin(origins = "http://xx.com")
</span><span class='line'>    @RequestMapping("/login")
</span><span class='line'>    public Result userLogin() {
</span><span class='line'>        // ...
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>@ExceptionHandler</h3>

<p>此注解使用在方法级别，声明对Exception的处理逻辑。可以指定目标Exception。</p>

<h3>@InitBinder</h3>

<p>此注解使用在方法上，声明对WebDataBinder的初始化(绑定请求参数到JavaBean上的DataBinder)。在controller上使用此注解可以自定义请求参数的绑定。</p>

<h3>@MatrixVariable</h3>

<p>此注解使用在请求handler方法的参数上，Spring可以注入matrix url中相关的值。这里的矩阵变量可以出现在url中的任何地方，变量之间用;分隔。如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// GET /pets/42;q=11;r=22
</span><span class='line'>@RequestMapping(value = "/pets/{petId}")
</span><span class='line'>public void findPet(@PathVariable String petId, @MatrixVariable int q) {
</span><span class='line'>    // petId == 42
</span><span class='line'>    // q == 11
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是默认Spring mvc是不支持矩阵变量的，需要开启。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;mvc:annotation-driven enable-matrix-variables="true" /&gt;</span></code></pre></td></tr></table></div></figure>


<p>注解配置则需要如下开启：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Configuration
</span><span class='line'>public class WebConfig extends WebMvcConfigurerAdapter {
</span><span class='line'> 
</span><span class='line'>    @Override
</span><span class='line'>    public void configurePathMatch(PathMatchConfigurer configurer) {
</span><span class='line'>        UrlPathHelper urlPathHelper = new UrlPathHelper();
</span><span class='line'>        urlPathHelper.setRemoveSemicolonContent(false);
</span><span class='line'>        configurer.setUrlPathHelper(urlPathHelper);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>@PathVariable</h3>

<p>此注解使用在请求handler方法的参数上。@RequestMapping可以定义动态路径，如:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@RequestMapping("/users/{uid}")</span></code></pre></td></tr></table></div></figure>


<p>可以使用@PathVariable将路径中的参数绑定到请求方法参数上。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@RequestMapping("/users/{uid}")
</span><span class='line'>public String execute(@PathVariable("uid") String uid){
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h3>@RequestAttribute</h3>

<p>此注解用在请求handler方法的参数上，用于将web请求中的属性(request attributes，是服务器放入的属性值)绑定到方法参数上。</p>

<h3>@RequestBody</h3>

<p>此注解用在请求handler方法的参数上，用于将http请求的Body映射绑定到此参数上。HttpMessageConverter负责将对象转换为http请求。</p>

<h3>@RequestHeader</h3>

<p>此注解用在请求handler方法的参数上，用于将http请求头部的值绑定到参数上。</p>

<h3>@RequestParam</h3>

<p>此注解用在请求handler方法的参数上，用于将http请求参数的值绑定到参数上。</p>

<h3>@RequestPart</h3>

<p>此注解用在请求handler方法的参数上，用于将文件之类的multipart绑定到参数上。</p>

<h4>@ResponseBody</h4>

<p>此注解用在请求handler方法上。和@RequestBody作用类似，用于将方法的返回对象直接输出到http响应中。</p>

<h3>@ResponseStatus</h3>

<p>此注解用于方法和exception类上，声明此方法或者异常类返回的http状态码。可以在Controller上使用此注解，这样所有的@RequestMapping都会继承。</p>

<h4>@ControllerAdvice</h4>

<p>此注解用于class上。前面说过可以对每一个controller声明一个ExceptionMethod。这里可以使用@ControllerAdvice来声明一个类来统一对所有@RequestMapping方法来做@ExceptionHandler、@InitBinder以及@ModelAttribute处理。</p>

<h3>@RestController</h3>

<p>此注解用于class上，声明此controller返回的不是一个视图而是一个领域对象。其同时引入了@Controller和@ResponseBody两个注解。</p>

<h3>@RestControllerAdvice</h3>

<p>此注解用于class上，同时引入了@ControllerAdvice和@ResponseBody两个注解。</p>

<h3>@SessionAttribute</h3>

<p>此注解用于方法的参数上，用于将session中的属性绑定到参数。</p>

<h3>@SessionAttributes</h3>

<p>此注解用于type级别，用于将JavaBean对象存储到session中。一般和@ModelAttribute注解一起使用。如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@ModelAttribute("user")
</span><span class='line'>
</span><span class='line'>public PUser getUser() {}
</span><span class='line'>
</span><span class='line'>// controller和上面的代码在同一controller中
</span><span class='line'>@Controller
</span><span class='line'>@SeesionAttributes(value = "user", types = {
</span><span class='line'>    User.class
</span><span class='line'>})
</span><span class='line'>
</span><span class='line'>public class UserController {}</span></code></pre></td></tr></table></div></figure>


<h2>五. 数据访问注解</h2>

<h3>@Transactional</h3>

<p>此注解使用在接口定义、接口中的方法、类定义或者类中的public方法上。需要注意的是此注解并不激活事务行为，它仅仅是一个元数据，会被一些运行时基础设施来消费。</p>

<h2>六. 任务执行、调度注解</h2>

<h3>@Scheduled</h3>

<p>此注解使用在方法上，声明此方法被定时调度。使用了此注解的方法返回类型需要是Void，并且不能接受任何参数。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@Scheduled(fixedDelay=1000)
</span><span class='line'>public void schedule() {
</span><span class='line'>
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@Scheduled(fixedRate=1000)
</span><span class='line'>public void schedulg() { 
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>第二个与第一个不同之处在于其不会等待上一次的任务执行结束。</p>

<h3>@Async</h3>

<p>此注解使用在方法上，声明此方法会在一个单独的线程中执行。不同于Scheduled注解，此注解可以接受参数。</p>

<p>使用此注解的方法的返回类型可以是Void也可是返回值。但是返回值的类型必须是一个Future。</p>

<h2>七. 测试注解</h2>

<h3>@ContextConfiguration</h3>

<p>此注解使用在Class上，声明测试使用的配置文件，此外，也可以指定加载上下文的类。</p>

<p>此注解一般需要搭配SpringJUnit4ClassRunner使用。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@RunWith(SpringJUnit4ClassRunner.class)
</span><span class='line'>@ContextConfiguration(classes = SpringCoreConfig.class)
</span><span class='line'>public class UserServiceTest {
</span><span class='line'>
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[有效解决问题]]></title>
    <link href="http://www.rowkey.me/blog/2017/10/20/solve-problems/"/>
    <updated>2017-10-20T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/10/20/solve-problems</id>
    <content type="html"><![CDATA[<p>来自于内部的一次培训，主要讲述了如何有效地解决问题，包括识别问题、描述问题、分析问题、找出方案、决策问题等。</p>

<!--more-->


<p><img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-2.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-3.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-4.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-5.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-6.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-7.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-8.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-9.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-10.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-11.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-12.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-13.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-14.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-15.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-16.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-17.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-18.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-19.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-20.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-21.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/solve_problem/arch-22.jpeg" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java9来了]]></title>
    <link href="http://www.rowkey.me/blog/2017/09/22/java9/"/>
    <updated>2017-09-22T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/09/22/java9</id>
    <content type="html"><![CDATA[<p>2017.9.21，Java9终于正式发布。其带来了诸如模块化、REPL环境、集合工厂方法等一系列有用的新特性。本文列出一些链接，可以通过阅读相关的内容来了解学习Java9。</p>

<h2>官方资料</h2>

<ul>
<li><a href="http://jdk.java.net/9/">JD9下载</a></li>
<li><a href="http://openjdk.java.net/projects/jdk9/">Java9新特性</a></li>
<li><a href="https://docs.oracle.com/javase/9/">Oracle的JDK文档</a></li>
<li><a href="http://mail.openjdk.java.net/pipermail/announce/2017-September/000230.html">Mark Reinhold的JDK9发布声明</a> [Mark Reinhold是Oracle的Java平台首席架构师]</li>
<li><a href="https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-7744EF96-5899-4FB2-B34E-86D49B2E89B6">迁移到Java9的提示</a></li>
<li><a href="https://blogs.oracle.com/theaquarium/java-ee-8-is-final-and-glassfish-50-is-released">JavaEE 8和GlassFish发布</a></li>
</ul>


<h2>第三方资料</h2>

<ul>
<li><a href="https://dzone.com/articles/java-9-besides-modules">Java9中除了模块化的其他新特性介绍</a></li>
<li><a href="https://dzone.com/articles/java-9-and-intellij-idea">Java 9 and IntelliJ IDEA</a></li>
<li>Java9对旧版本应用的支持: <a href="https://dzone.com/articles/yes-you-can-java-9-for-the-legacy-developer">https://dzone.com/articles/yes-you-can-java-9-for-the-legacy-developer</a>、<a href="https://dzone.com/articles/the-legacy-developers-guide-to-java-9">https://dzone.com/articles/the-legacy-developers-guide-to-java-9</a></li>
<li>Java9模块化开发：<a href="https://dzone.com/articles/java-9-modularity-jigsaw">第一部分</a>、<a href="https://dzone.com/articles/java-9-modular-development-part-2">第二部分</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译]Java中9个处理Exception的最佳实践]]></title>
    <link href="http://www.rowkey.me/blog/2017/09/17/java-exception/"/>
    <updated>2017-09-17T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/09/17/java-exception</id>
    <content type="html"><![CDATA[<p>在Java中处理异常并不是一个简单的事情。不仅仅初学者很难理解，即使一些有经验的开发者也需要花费很多时间来思考如何处理异常，包括需要处理哪些异常，怎样处理等等。这也是绝大多数开发团队都会制定一些规则来规范对异常的处理的原因。而团队之间的这些规范往往是截然不同的。</p>

<p>本文给出几个被很多团队使用的异常处理最佳实践。</p>

<!--more-->


<h2>1. 在Finally块中清理资源或者使用try-with-resource语句</h2>

<p>当使用类似InputStream这种需要使用后关闭的资源时，一个常见的错误就是在try块的最后关闭资源。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void doNotCloseResourceInTry() {
</span><span class='line'>    FileInputStream inputStream = null;
</span><span class='line'>    try {
</span><span class='line'>        File file = new File("./tmp.txt");
</span><span class='line'>        inputStream = new FileInputStream(file);
</span><span class='line'>        // use the inputStream to read a file
</span><span class='line'>        // do NOT do this
</span><span class='line'>        inputStream.close();
</span><span class='line'>    } catch (FileNotFoundException e) {
</span><span class='line'>        log.error(e);
</span><span class='line'>    } catch (IOException e) {
</span><span class='line'>        log.error(e);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上述代码在没有任何exception的时候运行是没有问题的。但是当try块中的语句抛出异常或者自己实现的代码抛出异常，那么就不会执行最后的关闭语句，从而资源也无法释放。</p>

<p>合理的做法则是将所有清理的代码都放到finally块中或者使用try-with-resource语句。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void closeResourceInFinally() {
</span><span class='line'>    FileInputStream inputStream = null;
</span><span class='line'>    try {
</span><span class='line'>        File file = new File("./tmp.txt");
</span><span class='line'>        inputStream = new FileInputStream(file);
</span><span class='line'>        // use the inputStream to read a file
</span><span class='line'>    } catch (FileNotFoundException e) {
</span><span class='line'>        log.error(e);
</span><span class='line'>    } finally {
</span><span class='line'>        if (inputStream != null) {
</span><span class='line'>            try {
</span><span class='line'>                inputStream.close();
</span><span class='line'>            } catch (IOException e) {
</span><span class='line'>                log.error(e);
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public void automaticallyCloseResource() {
</span><span class='line'>    File file = new File("./tmp.txt");
</span><span class='line'>    try (FileInputStream inputStream = new FileInputStream(file);) {
</span><span class='line'>        // use the inputStream to read a file
</span><span class='line'>    } catch (FileNotFoundException e) {
</span><span class='line'>        log.error(e);
</span><span class='line'>    } catch (IOException e) {
</span><span class='line'>        log.error(e);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>2. 指定具体的异常</h2>

<p>尽可能的使用最具体的异常来声明方法，这样才能使得代码更容易理解。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void doNotDoThis() throws Exception {
</span><span class='line'>    ...
</span><span class='line'>}
</span><span class='line'>public void doThis() throws NumberFormatException {
</span><span class='line'>    ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如上，NumberFormatException字面上即可以看出是数字格式化错误。</p>

<h2>3. 对异常进行文档说明</h2>

<p>当在方法上声明抛出异常时，也需要进行文档说明。和前面的一点一样，都是为了给调用者提供尽可能多的信息，从而可以更好地避免/处理异常。</p>

<p>在Javadoc中加入throws声明，并且描述抛出异常的场景。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>/**
</span><span class='line'> * This method does something extremely useful ...
</span><span class='line'> *
</span><span class='line'> * @param input
</span><span class='line'> * @throws MyBusinessException if ... happens
</span><span class='line'> */
</span><span class='line'>public void doSomething(String input) throws MyBusinessException {
</span><span class='line'>    ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>4. 抛出异常的时候包含描述信息</h2>

<p>在抛出异常时，需要尽可能精确地描述问题和相关信息，这样无论是打印到日志中还是监控工具中，都能够更容易被人阅读，从而可以更好地定位具体错误信息、错误的严重程度等。</p>

<p>但这里并不是说要对错误信息长篇大论，因为本来Exception的类名就能够反映错误的原因，因此只需要用一到两句话描述即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>try {
</span><span class='line'>    new Long("xyz");
</span><span class='line'>} catch (NumberFormatException e) {
</span><span class='line'>    log.error(e);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>NumberFormatException即告诉了这个异常是格式化错误，异常的额外信息只需要提供这个错误字符串即可。当异常的名称不够明显的时候，则需要提供尽可能具体的错误信息。</p>

<h2>5. 首先捕获最具体的异常</h2>

<p>现在很多IDE都能智能提示这个最佳实践，当你试图首先捕获最笼统的异常时，会提示<strong><em>不能达到的代码</em></strong>。</p>

<p>当有多个catch块中，按照捕获顺序只有第一个匹配到的catch块才能执行。因此，如果先捕获IllegalArgumentException，那么则无法运行到对NumberFormatException的捕获。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void catchMostSpecificExceptionFirst() {
</span><span class='line'>    try {
</span><span class='line'>        doSomething("A message");
</span><span class='line'>    } catch (NumberFormatException e) {
</span><span class='line'>        log.error(e);
</span><span class='line'>    } catch (IllegalArgumentException e) {
</span><span class='line'>        log.error(e)
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>6. 不要捕获Throwable</h2>

<p>Throwable是所有异常和错误的父类。你可以在catch语句中捕获，但是永远不要这么做。</p>

<p>如果catch了throwable，那么不仅仅会捕获所有exception，还会捕获error。而error是表明无法恢复的jvm错误。因此除非绝对肯定能够处理或者被要求处理error，不要捕获throwable。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void doNotCatchThrowable() {
</span><span class='line'>    try {
</span><span class='line'>        // do something
</span><span class='line'>    } catch (Throwable t) {
</span><span class='line'>        // don't do this!
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>7. 不要忽略异常</h2>

<p>很多时候，开发者很有自信不会抛出异常，因此写了一个catch块，但是没有做任何处理或者记录日志。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>public void doNotIgnoreExceptions() {
</span><span class='line'>    try {
</span><span class='line'>        // do something
</span><span class='line'>    } catch (NumberFormatException e) {
</span><span class='line'>        // this will never happen
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>但现实是经常会出现无法预料的异常或者无法确定这里的代码未来是不是会改动(删除了阻止异常抛出的代码)，而此时由于异常被捕获，使得无法拿到足够的错误信息来定位问题。</p>

<p>合理的做法是至少要记录异常的信息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void logAnException() {
</span><span class='line'>    try {
</span><span class='line'>        // do something
</span><span class='line'>    } catch (NumberFormatException e) {
</span><span class='line'>        log.error("This should never happen: " + e);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>8. 不要记录并抛出异常</h2>

<p>可以发现很多代码甚至类库中都会有捕获异常、记录日志并再次抛出的逻辑。如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>try {
</span><span class='line'>    new Long("xyz");
</span><span class='line'>} catch (NumberFormatException e) {
</span><span class='line'>    log.error(e);
</span><span class='line'>    throw e;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这个处理逻辑看着是合理的。但这经常会给同一个异常输出多条日志。如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>17:44:28,945 ERROR TestExceptionHandling:65 - java.lang.NumberFormatException: For input string: "xyz"
</span><span class='line'>Exception in thread "main" java.lang.NumberFormatException: For input string: "xyz"
</span><span class='line'>at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
</span><span class='line'>at java.lang.Long.parseLong(Long.java:589)
</span><span class='line'>at java.lang.Long.(Long.java:965)
</span><span class='line'>at com.stackify.example.TestExceptionHandling.logAndThrowException(TestExceptionHandling.java:63)
</span><span class='line'>at com.stackify.example.TestExceptionHandling.main(TestExceptionHandling.java:58)</span></code></pre></td></tr></table></div></figure>


<p>如上所示，后面的日志也没有附加更有用的信息。如果想要提供更加有用的信息，那么可以将异常包装为自定义异常。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>public void wrapException(String input) throws MyBusinessException {
</span><span class='line'>    try {
</span><span class='line'>        // do something
</span><span class='line'>    } catch (NumberFormatException e) {
</span><span class='line'>        throw new MyBusinessException("A message that describes the error.", e);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>因此，仅仅当想要处理异常时才去捕获，否则只需要在方法签名中声明让调用者去处理。</p>

<h2>9. 包装异常时不要抛弃原始的异常</h2>

<p>捕获标准异常并包装为自定义异常是一个很常见的做法。这样可以添加更为具体的异常信息并能够做针对的异常处理。</p>

<p>需要注意的是，包装异常时，一定要把原始的异常设置为cause(Exception有构造方法可以传入cause)。否则，丢失了原始的异常信息会让错误的分析变得困难。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void wrapException(String input) throws MyBusinessException {
</span><span class='line'>    try {
</span><span class='line'>        // do something
</span><span class='line'>    } catch (NumberFormatException e) {
</span><span class='line'>        throw new MyBusinessException("A message that describes the error.", e);
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>总结</h2>

<p>综上可知，当抛出或者捕获异常时，有很多不一样的东西需要考虑。其中的许多点都是为了提升代码的可阅读性或者api的可用性。</p>

<p>异常不仅仅是一个错误控制机制，也是一个沟通媒介，因此与你的协作者讨论这些最佳实践并制定一些规范能够让每个人都理解相关的通用概念并且能够按照同样的方式使用它们。</p>

<p>原文链接: <a href="https://dzone.com/articles/9-best-practices-to-handle-exceptions-in-java">https://dzone.com/articles/9-best-practices-to-handle-exceptions-in-java</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译]Java中的十个"单行代码编程"(One Liner)]]></title>
    <link href="http://www.rowkey.me/blog/2017/09/09/java-oneliners/"/>
    <updated>2017-09-09T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/09/09/java-oneliners</id>
    <content type="html"><![CDATA[<p>本文列举了十个使用一行代码即可独立完成(不依赖其他代码)的业务逻辑，主要依赖的是Java8中的Lambda和Stream等新特性以及try-with-resources、JAXB等。</p>

<!--more-->


<ol>
<li><p>对列表/数组中的每个元素都乘以2</p>

<pre><code class="`"> // Range是半开区间
 int[] ia = range(1, 10).map(i -&gt; i * 2).toArray();
 List&lt;Integer&gt; result = range(1, 10).map(i -&gt; i * 2).boxed().collect(toList());
</code></pre></li>
<li><p>计算集合/数组中的数字之和</p>

<pre><code class="`"> range(1, 1000).sum();
 range(1, 1000).reduce(0, Integer::sum);
 Stream.iterate(0, i -&gt; i + 1).limit(1000).reduce(0, Integer::sum);
 IntStream.iterate(0, i -&gt; i + 1).limit(1000).reduce(0, Integer::sum);
</code></pre></li>
<li><p>验证字符串是否包含集合中的某一字符串</p>

<pre><code class="`">final List&lt;String&gt; keywords = Arrays.asList("brown", "fox", "dog", "pangram");
final String tweet = "The quick brown fox jumps over a lazy dog. #pangram http://www.rinkworks.com/words/pangrams.shtml";

keywords.stream().anyMatch(tweet::contains);
keywords.stream().reduce(false, (b, keyword) -&gt; b || tweet.contains(keyword), (l, r) -&gt; l || r);
</code></pre></li>
<li><p>读取文件内容</p>

<blockquote><p>原作者认为try with resources也是一种单行代码编程。</p></blockquote>

<pre><code class="`"> try (BufferedReader reader = new BufferedReader(new FileReader("data.txt"))) {
   String fileText = reader.lines().reduce("", String::concat);
 }

 try (BufferedReader reader = new BufferedReader(new FileReader("data.txt"))) {
   List&lt;String&gt; fileLines = reader.lines().collect(toCollection(LinkedList&lt;String&gt;::new));
 }

 try (Stream&lt;String&gt; lines = Files.lines(new File("data.txt").toPath(), Charset.defaultCharset())) {
   List&lt;String&gt; fileLines = lines.collect(toCollection(LinkedList&lt;String&gt;::new));
 }
</code></pre></li>
<li><p>输出歌曲《Happy Birthday to You!》 - 根据集合中不同的元素输出不同的字符串</p>

<pre><code class="`"> range(1, 5).boxed().map(i -&gt; { out.print("Happy Birthday "); if (i == 3) return "dear NAME"; else return "to You"; }).forEach(out::println);
</code></pre></li>
<li><p>过滤并分组集合中的数字</p>

<pre><code class="`"> Map&lt;String, List&lt;Integer&gt;&gt; result = Stream.of(49, 58, 76, 82, 88, 90).collect(groupingBy(forPredicate(i -&gt; i &gt; 60, "passed", "failed")));
</code></pre></li>
<li><p>获取并解析xml协议的Web Service</p>

<pre><code class="`">FeedType feed = JAXB.unmarshal(new URL("http://search.twitter.com/search.atom?&amp;q=java8"), FeedType.class);
JAXB.marshal(feed, System.out);
</code></pre></li>
<li><p>获得集合中最小/最大的数字</p>

<pre><code class="`"> int min = Stream.of(14, 35, -7, 46, 98).reduce(Integer::min).get();
 min = Stream.of(14, 35, -7, 46, 98).min(Integer::compare).get();
 min = Stream.of(14, 35, -7, 46, 98).mapToInt(Integer::new).min();

 int max = Stream.of(14, 35, -7, 46, 98).reduce(Integer::max).get();
 max = Stream.of(14, 35, -7, 46, 98).max(Integer::compare).get();
 max = Stream.of(14, 35, -7, 46, 98).mapToInt(Integer::new).max();
</code></pre></li>
<li><p>并行处理</p>

<pre><code class="`"> long result = dataList.parallelStream().mapToInt(line -&gt; processItem(line)).sum();
</code></pre></li>
<li><p>集合上的各种查询(LINQ in Java)</p>

<pre><code>List&lt;Album&gt; albums = Arrays.asList(unapologetic, tailgates, red);

//筛选出至少有一个track评级4分以上的专辑，并按照名称排序后打印出来。
albums.stream()
  .filter(a -&gt; a.tracks.stream().anyMatch(t -&gt; (t.rating &gt;= 4)))
  .sorted(comparing(album -&gt; album.name))
  .forEach(album -&gt; System.out.println(album.name));

//合并所有专辑的track
List&lt;Track&gt; allTracks = albums.stream()
  .flatMap(album -&gt; album.tracks.stream())
  .collect(toList());

//根据track的评分对所有track分组
Map&lt;Integer, List&lt;Track&gt;&gt; tracksByRating = allTracks.stream()
  .collect(groupingBy(Track::getRating));
</code></pre></li>
</ol>


<p>原文: <a href="https://github.com/aruld/java-oneliners/wiki">https://github.com/aruld/java-oneliners/wiki</a></p>

<hr />

<p><strong><em>补充 by 飒然Hang</em></strong>: 上述的<strong>单行代码编程</strong>确实能够减少代码的字符数，也经常能够给人以高大上的感觉，但是在Java编程中字符其实是非常廉价的，尤其是现在诸如Intellij等IDE已经具有自动补充/生成代码、重构等智能化功能。如果仅仅是为了减少字符的数量，那么没必要刻意去追求<strong>单行代码编程</strong>。让你的代码易于阅读才是最关键的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译]更好地使用Java8中的方法引用]]></title>
    <link href="http://www.rowkey.me/blog/2017/09/02/java8-method-reference-work/"/>
    <updated>2017-09-02T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/09/02/java8-method-reference-work</id>
    <content type="html"><![CDATA[<p>在Java8中，使用方法引用非常简单，如String::isEmpty，但无法使用它否定的方法引用。本文内容即如何解决此问题使得我们能够更加全面地使用方法引用。</p>

<!--more-->


<p>首先看一个使用方法引用的例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Stream.of("A", "", "B").filter(String::isEmpty).count()</span></code></pre></td></tr></table></div></figure>


<p>上面代码的输出为1，即空字符串的数目。如果我们想要获取非空字符串的数目，就不能直接使用方法引用了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Stream.of("A", "", "B").filter(s -&gt; !s.isEmpty()).count()</span></code></pre></td></tr></table></div></figure>


<p>Java8中的Predicate，有predicate.negate()可以转换为断言的否定形式，但String::isEmpty却无法这么做(String::isEmpty.negate()或者!String::isEmpty)。因为方法引用并不是一个lambda或者函数接口，它能够被解析为一个或者多个函数接口。如，String::isEmpty至少可以被解析如下：</p>

<ul>
<li><code>Predicate&lt;String&gt;</code></li>
<li><code>Function&lt;String, Boolean&gt;</code></li>
</ul>


<p>为了解决上述的问题，我们可以通过某种机制显式地将方法引用转换为一个函数接口：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public static &lt;T&gt; Predicate&lt;T&gt; as(Predicate&lt;T&gt; predicate) {
</span><span class='line'>    return predicate;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>通过使用一个静态方法，接受方法引用参数，返回一个函数接口，即可实现方法引用到函数接口的转换。接着，我们就可以使用方法引用来实现上面例子中的获取非空字符串的数目。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Stream.of("A", "", "B").filter(as(String::isEmpty).negate()).count();</span></code></pre></td></tr></table></div></figure>


<p>进一步还能使用各种组合的Predicate。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.filter(as(String::isEmpty).negate().and("A"::equals))</span></code></pre></td></tr></table></div></figure>


<p>由于一个方法引用可能会被解析为多种函数接口，因此如果我们实现很多参数不同的as方法，那么很容易造成混淆。更好的方式则是在方法名中加入函数参数的类型来区分。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import java.util.function.*;
</span><span class='line'>
</span><span class='line'>public class FunctionCastUtil {
</span><span class='line'>    public static &lt;T, U&gt; BiConsumer&lt;T, U&gt; asBiConsumer(BiConsumer&lt;T, U&gt; biConsumer) {
</span><span class='line'>        return biConsumer;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T, U, R&gt; BiFunction&lt;T, U, R&gt; asBiFunction(BiFunction&lt;T, U, R&gt; biFunction) {
</span><span class='line'>        return biFunction;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; BinaryOperator&lt;T&gt; asBinaryOperator(BinaryOperator&lt;T&gt; binaryOperator) {
</span><span class='line'>        return binaryOperator;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T, U&gt; BiPredicate&lt;T, U&gt; asBiPredicate(BiPredicate&lt;T, U&gt; biPredicate) {
</span><span class='line'>        return biPredicate;
</span><span class='line'>    }
</span><span class='line'>    public static BooleanSupplier asBooleanSupplier(BooleanSupplier booleanSupplier) {
</span><span class='line'>        return booleanSupplier;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; Consumer&lt;T&gt; asConsumer(Consumer&lt;T&gt; consumer) {
</span><span class='line'>        return consumer;
</span><span class='line'>    }
</span><span class='line'>    public static DoubleBinaryOperator asDoubleBinaryOperator(DoubleBinaryOperator doubleBinaryOperator) {
</span><span class='line'>        return doubleBinaryOperator;
</span><span class='line'>    }
</span><span class='line'>    public static DoubleConsumer asDoubleConsumer(DoubleConsumer doubleConsumer) {
</span><span class='line'>        return doubleConsumer;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;R&gt; DoubleFunction&lt;R&gt; asDoubleFunction(DoubleFunction&lt;R&gt; doubleFunction) {
</span><span class='line'>        return doubleFunction;
</span><span class='line'>    }
</span><span class='line'>    public static DoublePredicate asDoublePredicate(DoublePredicate doublePredicate) {
</span><span class='line'>        return doublePredicate;
</span><span class='line'>    }
</span><span class='line'>    public static DoubleToIntFunction asDoubleToIntFunction(DoubleToIntFunction doubleToIntFunctiontem) {
</span><span class='line'>        return doubleToIntFunctiontem;
</span><span class='line'>    }
</span><span class='line'>    public static DoubleToLongFunction asDoubleToLongFunction(DoubleToLongFunction doubleToLongFunction) {
</span><span class='line'>        return doubleToLongFunction;
</span><span class='line'>    }
</span><span class='line'>    public static DoubleUnaryOperator asDoubleUnaryOperator(DoubleUnaryOperator doubleUnaryOperator) {
</span><span class='line'>        return doubleUnaryOperator;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T, R&gt; Function&lt;T, R&gt; asFunction(Function&lt;T, R&gt; function) {
</span><span class='line'>        return function;
</span><span class='line'>    }
</span><span class='line'>    public static IntBinaryOperator asIntBinaryOperator(IntBinaryOperator intBinaryOperator) {
</span><span class='line'>        return intBinaryOperator;
</span><span class='line'>    }
</span><span class='line'>    public static IntConsumer asIntConsumer(IntConsumer intConsumer) {
</span><span class='line'>        return intConsumer;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;R&gt; IntFunction&lt;R&gt; asIntFunction(IntFunction&lt;R&gt; intFunction) {
</span><span class='line'>        return intFunction;
</span><span class='line'>    }
</span><span class='line'>    public static IntPredicate asIntPredicate(IntPredicate intPredicate) {
</span><span class='line'>        return intPredicate;
</span><span class='line'>    }
</span><span class='line'>    public static IntSupplier asIntSupplier(IntSupplier intSupplier) {
</span><span class='line'>        return intSupplier;
</span><span class='line'>    }
</span><span class='line'>    public static IntToDoubleFunction asIntToDoubleFunction(IntToDoubleFunction intToDoubleFunction) {
</span><span class='line'>        return intToDoubleFunction;
</span><span class='line'>    }
</span><span class='line'>    public static IntToLongFunction asIntToLongFunction(IntToLongFunction intToLongFunction) {
</span><span class='line'>        return intToLongFunction;
</span><span class='line'>    }
</span><span class='line'>    public static IntUnaryOperator asIntUnaryOperator(IntUnaryOperator intUnaryOperator) {
</span><span class='line'>        return intUnaryOperator;
</span><span class='line'>    }
</span><span class='line'>    public static LongBinaryOperator asLongBinaryOperator(LongBinaryOperator longBinaryOperator) {
</span><span class='line'>        return longBinaryOperator;
</span><span class='line'>    }
</span><span class='line'>    public static LongConsumer asLongConsumer(LongConsumer longConsumer) {
</span><span class='line'>        return longConsumer;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;R&gt; LongFunction&lt;R&gt; asLongFunction(LongFunction&lt;R&gt; longFunction) {
</span><span class='line'>        return longFunction;
</span><span class='line'>    }
</span><span class='line'>    public static LongPredicate asLongPredicate(LongPredicate longPredicate) {
</span><span class='line'>        return longPredicate;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; LongSupplier asLongSupplier(LongSupplier longSupplier) {
</span><span class='line'>        return longSupplier;
</span><span class='line'>    }
</span><span class='line'>    public static LongToDoubleFunction asLongToDoubleFunction(LongToDoubleFunction longToDoubleFunction) {
</span><span class='line'>        return longToDoubleFunction;
</span><span class='line'>    }
</span><span class='line'>    public static LongToIntFunction asLongToIntFunction(LongToIntFunction longToIntFunction) {
</span><span class='line'>        return longToIntFunction;
</span><span class='line'>    }
</span><span class='line'>    public static LongUnaryOperator asLongUnaryOperator(LongUnaryOperator longUnaryOperator) {
</span><span class='line'>        return longUnaryOperator;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; ObjDoubleConsumer&lt;T&gt; asObjDoubleConsumer(ObjDoubleConsumer&lt;T&gt; objDoubleConsumer) {
</span><span class='line'>        return objDoubleConsumer;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; ObjIntConsumer&lt;T&gt; asObjIntConsumer(ObjIntConsumer&lt;T&gt; objIntConsumer) {
</span><span class='line'>        return objIntConsumer;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; ObjLongConsumer&lt;T&gt; asObjLongConsumer(ObjLongConsumer&lt;T&gt; objLongConsumer) {
</span><span class='line'>        return objLongConsumer;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; Predicate&lt;T&gt; asPredicate(Predicate&lt;T&gt; predicate) {
</span><span class='line'>        return predicate;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; Supplier&lt;T&gt; asSupplier(Supplier&lt;T&gt; supplier) {
</span><span class='line'>        return supplier;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T, U&gt; ToDoubleBiFunction&lt;T, U&gt; asToDoubleBiFunction(ToDoubleBiFunction&lt;T, U&gt; toDoubleBiFunction) {
</span><span class='line'>        return toDoubleBiFunction;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; ToDoubleFunction&lt;T&gt; asToDoubleFunction(ToDoubleFunction&lt;T&gt; toDoubleFunction) {
</span><span class='line'>        return toDoubleFunction;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T, U&gt; ToIntBiFunction&lt;T, U&gt; asToIntBiFunction(ToIntBiFunction&lt;T, U&gt; toIntBiFunction) {
</span><span class='line'>        return toIntBiFunction;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; ToIntFunction&lt;T&gt; asToIntFunction(ToIntFunction&lt;T&gt; ioIntFunction) {
</span><span class='line'>        return ioIntFunction;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T, U&gt; ToLongBiFunction&lt;T, U&gt; asToLongBiFunction(ToLongBiFunction&lt;T, U&gt; toLongBiFunction) {
</span><span class='line'>        return toLongBiFunction;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; ToLongFunction&lt;T&gt; asToLongFunction(ToLongFunction&lt;T&gt; toLongFunction) {
</span><span class='line'>        return toLongFunction;
</span><span class='line'>    }
</span><span class='line'>    public static &lt;T&gt; UnaryOperator&lt;T&gt; asUnaryOperator(UnaryOperator&lt;T&gt; unaryOperator) {
</span><span class='line'>        return unaryOperator;
</span><span class='line'>    }
</span><span class='line'>    private FunctionCastUtil() {
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>Stream.of("A", "", "B").filter(asPredicate(String::isEmpty).negate()).count();</span></code></pre></td></tr></table></div></figure>


<p>英文原文：<a href="https://dzone.com/articles/put-your-java-8-method-references-to-work">https://dzone.com/articles/put-your-java-8-method-references-to-work</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谈谈架构]]></title>
    <link href="http://www.rowkey.me/blog/2017/08/24/arch/"/>
    <updated>2017-08-24T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/08/24/arch</id>
    <content type="html"><![CDATA[<p>之前开头的《架构设计原则》一文一直没有把坑填上。而最近在公司内部做了一次架构交流/培训，把架构的概念、架构的形式、架构设计原则都做了阐述，正好算是对此文的完成和补充。</p>

<p><a href="http://www.rowkey.me/arch-ppt/index.html" target="_blank">PPT观看</a></p>

<!--more-->


<p><img src="http://www.rowkey.me/images/blog_images/arch/arch-2.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-3.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-4.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-5.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-6.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-7.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-8.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-9.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-10.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-11.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-12.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-13.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-14.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-15.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-16.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-17.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-18.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-19.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-20.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-21.jpeg" alt="" />
<img src="http://www.rowkey.me/images/blog_images/arch/arch-22.jpeg" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译]在Java中提升函数以更好地“函数式”编程]]></title>
    <link href="http://www.rowkey.me/blog/2017/08/18/lift-functions/"/>
    <updated>2017-08-18T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/08/18/lift-functions</id>
    <content type="html"><![CDATA[<p>Java8中的Stream和Optional给我们带来了函数式编程的乐趣，但Java仍然缺少很多函数编程的关键特性。Lambda表达式、Optional和Stream只是函数式编程的冰山一角。这也导致了<a href="https://github.com/vavr-io/vavr">varvr</a>和<a href="https://github.com/functionaljava/functionaljava">functionlajava</a>这些类库的出现，他们都源于Haskell这个纯函数式编程语言。</p>

<p>如果想要更加地“函数式”编程，那么首先要注意的是不要过早的中断monad(一种设计模式，表示将一个运算过程通过函数拆解成互相连接的多个步骤。只要提供下一步运算所需的函数，整个运算就会自动进行下去, Optional、Stream都是monad)，比如，很多人经常会在还不需要的时候就调用了Optional.get()和Stream.collect()提前终止monad。本文主要讲述如何通过提升方法来使得代码更&#8221;函数式&#8221;。</p>

<!--more-->


<p>假设有一个接口可以对数字进行计算。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public interface Math {
</span><span class='line'>    int multiply(int a, int b);
</span><span class='line'>    double divide(int a, int b);
</span><span class='line'>    ..
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>我们要使用这个接口来对使用Optional做包装的数字做计算。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public interface NumberProvider {
</span><span class='line'>    Optional&lt;Integer&gt; getNumber();
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>接着我们来实现一个方法能够返回两个数字相除的结果，结果用Optional包装。如果这两个数字有一个为空则返回空Optional。如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public Optional&lt;Double&gt; divideFirstTwo(NumberProvider numberProvider, Math math) {
</span><span class='line'>    Optional&lt;Integer&gt; first = numberProvider.getNumber();
</span><span class='line'>    Optional&lt;Integer&gt; second = numberProvider.getNumber();
</span><span class='line'>    if(first.isPresent() && second.isPresent()) {
</span><span class='line'>        double result = math.divide(first.get(), second.get());
</span><span class='line'>        return Optional.of(result);
</span><span class='line'>    } else {
</span><span class='line'>        return Optional.empty();
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>上面的代码非常不优雅，有大量的代码都是在做Optional的包装和解包装。可以让上面的代码变得更加“函数式”，如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public Optional&lt;Double&gt; divideFirstTwo(NumberProvider numberProvider, Math math) {
</span><span class='line'>    return numberProvider.getNumber()
</span><span class='line'>           .flatMap(first -&gt; numberProvider.getNumber()
</span><span class='line'>                                     .map(second -&gt; math.divide(first, second)));
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这样代码少了很多，也优雅了很多。先调用第一个Optional的flatMap，再在lambda中调用第二个Optional的map，进一步可以抽取出一个提升方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public interface Optionals {
</span><span class='line'>    static &lt;R, T, Z&gt; BiFunction&lt;Optional&lt;T&gt;, Optional&lt;R&gt;, Optional&lt;Z&gt;&gt; lift(BiFunction&lt;? super T, ? super R, ? extends Z&gt; function) {
</span><span class='line'>        return (left, right) -&gt; left.flatMap(leftVal -&gt; right.map(rightVal -&gt; function.apply(leftVal, rightVal)));
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如上，可知这个方法提升能够提升任何具有两个Optional参数、一个Optional结果的函数，使得被提升的函数具有Optional的一个特性：如果一个参数是空的，那么结果就是空的。如果JDK抽取flatMap和map到一个公共接口，如Monad，那么我们可以为Java Monad的每一个实例(Stream、Optional、自己的实现类)实现一个公共的提升函数。但现实是我们不得不为每一个实例都复制粘贴上面的代码。最终的divideFirstTwo代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import static com.ps.functional.monad.optional.Optionals.lift;
</span><span class='line'>...
</span><span class='line'>public Optional&lt;Double&gt; divideFirstTwo(NumberProvider numberProvider, Math math) {
</span><span class='line'>    return lift(math::divide).apply(numberProvider.getNumber(), numberProvider.getNumber());
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p><strong>ps: 此文内容来自<a href="https://dzone.com/articles/lifting-functions-to-work-with-monads-in-java?edition=311409&amp;edition=0&amp;utm_source=Zone%20Newsletter&amp;utm_medium=email&amp;utm_campaign=java%202017-08-01">https://dzone.com/articles/lifting-functions-to-work-with-monads-in-java?edition=311409&amp;edition=0&amp;utm_source=Zone%20Newsletter&amp;utm_medium=email&amp;utm_campaign=java%202017-08-01</a>，加入了本人的理解和认知。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《Java工程师修炼之道》内容概览]]></title>
    <link href="http://www.rowkey.me/blog/2017/08/10/pragmatic-java-engineer/"/>
    <updated>2017-08-10T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/08/10/pragmatic-java-engineer</id>
    <content type="html"><![CDATA[<p>最近几个月由于工作和正在筹备《Java工程师修炼之道》一书的原因一直没有写新的文章。不过，忙里偷闲，自己陆续读完了《格鲁夫给经理人的第一课》、《架构真经》、《聊聊架构》这几本书，收获了不少干货，之前自己挖坑的《一些架构设计原则》一文后面会尽快填上。本文则先介绍一下《Java工程师修炼之道》一书^_^。</p>

<p>《Java工程师修炼之道》一书主要内容是Java后端工程师必备的基本技能大纲。内容主要来自于公司内的后端工程师学习计划、自己以前的一些博客文章和自己从业以来积累的知识库。但由于后端工程师的每一个技能点都具有一定的深度，都不是一两篇文章就能讲述清楚的，因此本书不可能对每一个技能点都讲的特别透彻。</p>

<p>本书可以看做是一本Java工程师的入职指南，也可以看做一本串联Java后端技能点的参考手册。对其中每一个技能点的学习，推荐通过他们的官方文档来深入学习，此外，本书也给出了自己觉得有价值的参考学习书籍。</p>

<!--more-->


<p>初步的目录如下：</p>

<ul>
<li><p>第一章 后端技术导言</p>

<ul>
<li>1.1 后端基础设施</li>
<li>1.2 Java后端技术概览</li>
<li>1.3 如何学习后端技术</li>
</ul>
</li>
<li><p>第二章 Java项目工程化</p>

<ul>
<li>2.1 项目构建</li>
<li>2.2 代码版本协作</li>
<li>2.3 代码质量</li>
</ul>
</li>
<li><p>第三章 开发框架</p>

<ul>
<li>3.1 依赖注入</li>
<li>3.2 对象关系映射</li>
<li>3.3 日志</li>
<li>3.4 Web MVC</li>
</ul>
</li>
<li><p>第四章 Spring</p>

<ul>
<li>4.1 Spring Core</li>
<li>4.2 数据操作</li>
<li>4.3 Spring Boot</li>
<li>4.4 常用组件</li>
<li>4.5 总结</li>
</ul>
</li>
<li><p>第五章 数据存储</p>

<ul>
<li>5.1 关系型数据库</li>
<li>5.2 NoSQL数据库</li>
<li>5.3 缓存</li>
<li>5.4 搜索引擎</li>
</ul>
</li>
<li><p>第六章 数据通信</p>

<ul>
<li>6.1 RESTful</li>
<li>6.2 RPC</li>
<li>6.3 消息队列</li>
</ul>
</li>
<li><p>第七章 Java编程进阶</p>

<ul>
<li>7.1 Java内存管理</li>
<li>7.2 Java网络编程</li>
<li>7.3 Java并发编程</li>
<li>7.4 Java开发利器</li>
<li>7.5 New Java</li>
<li>7.6 总结</li>
</ul>
</li>
<li><p>第八章 性能调优</p>

<ul>
<li>8.1 调优准备</li>
<li>8.2 性能分析</li>
<li>8.3 性能调优</li>
</ul>
</li>
<li><p>第九章 安全技术</p>

<ul>
<li>9.1 Java加密</li>
<li>9.2 HTTPS</li>
<li>9.3 Web安全</li>
</ul>
</li>
</ul>


<p>其中的部分内容，会在此书正式出版后陆续放出。</p>

<p><strong>希望这本书会给想要学习Java后端开发的同学或者还未形成自己技术体系的Java工程师们带来帮助。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM诊断调优CheatSheet]]></title>
    <link href="http://www.rowkey.me/blog/2017/03/23/java-profile-cheatsheet/"/>
    <updated>2017-03-23T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/03/23/java-profile-cheatsheet</id>
    <content type="html"><![CDATA[<p>包含诊断调优java应用的各种命令以及jvm配置示例。</p>

<h2>常用Shell命令</h2>

<ul>
<li><p>查看网络状况</p>

<pre><code>  netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
</code></pre></li>
<li><p>使用top去获取进程cpu使用率；使用/proc文件查看进程所占内存。</p>

<pre><code>  #!/bin/bash
  for i in `ps -ef | egrep -v "awk|$0" | awk '/'$1'/{print $2}'`
  do
      mymem=`cat /proc/$i/status 2&gt; /dev/null | grep VmRSS | awk '{print $2" " $3}'`
      cpu=`top -n 1 -b |awk '/'$i'/{print $9}'`
  done
</code></pre></li>
</ul>


<!--more-->


<h2>常用JDK命令</h2>

<ul>
<li><p>查看类的一些信息，如字节码的版本号、常量池等</p>

<blockquote><p>javap -verbose classname</p></blockquote></li>
<li><p>查看jvm进程</p>

<blockquote><p>jps</p>

<p>jcmd -l</p></blockquote></li>
<li><p>查看进程的gc情况</p>

<blockquote><p>jstat -gcutil [pid] (显示总体情况)</p>

<p>jstat -gc [pid] 1000 10（每隔1秒刷新一次 一共10次）</p></blockquote></li>
<li><p>查看jvm内存使用状况</p>

<blockquote><p>jmap -heap [pid]</p></blockquote></li>
<li><p>查看jvm内存存活的对象：</p>

<blockquote><p>jcmd [pid] GC.class_histogram</p>

<p>jmap -histo:live [pid]</p></blockquote></li>
<li><p>把heap里所有对象都dump下来，无论对象是死是活</p>

<blockquote><p>jmap -dump:format=b,file=xxx.hprof [pid]</p></blockquote></li>
<li><p>先做一次full GC，再dump，只包含仍然存活的对象信息：</p>

<blockquote><p>jcmd [PID] GC.heap_dump [FILENAME]</p>

<p>jmap -dump:format=b,live,file=xxx.hprof [pid]</p></blockquote></li>
<li><p>线程dump</p>

<blockquote><p>jstack [pid] #-m参数可以打印出native栈的信息</p>

<p>jcmd <PID> Thread.print</p>

<p>kill -3 [pid]</p></blockquote></li>
<li><p>查看目前jvm启动的参数</p>

<blockquote><p>jinfo -flags [pid] #有效参数</p>

<p>jcmd [pid] VM.flags #所有参数</p></blockquote></li>
<li><p>查看对应参数的值</p>

<blockquote><p>jinfo -flag [flagName] [pid]</p></blockquote></li>
<li><p>启用/禁止某个参数</p>

<blockquote><p>jinfo -flag [+/-][flagName] [pid]</p></blockquote></li>
<li><p>设置某个参数</p>

<blockquote><p>jinfo -flag [flagName=value] [pid]</p></blockquote></li>
<li><p>查看所有可以设置的参数以及其默认值</p>

<blockquote><p>java -XX:+PrintFlagsInitial</p></blockquote></li>
</ul>


<h2>第三方工具</h2>

<p><strong>========<a href="https://github.com/superhj1987/awesome-scripts/blob/master/README.md">awesome-scripts</a>========</strong></p>

<p><strong>安装:</strong></p>

<p><code>curl -s "https://raw.githubusercontent.com/superhj1987/awesome-scripts/master/self-installer.sh" | bash -s</code></p>

<p><strong>使用：</strong></p>

<ul>
<li><p>显示最繁忙的java线程: -c &lt;要显示的线程栈数> -p &lt;指定的Java Process></p>

<blockquote><p>opscipts show-busy-java-threads [-c] [-p]</p></blockquote></li>
<li><p>使用greys跟踪方法耗时</p>

<blockquote><p>opscripts greys <PID>[@IP:PORT]</p>

<p><strong><em>ga?:</em></strong> trace [class] [method]</p></blockquote></li>
<li><p>显示当前cpu和内存使用状况，包括全局和各个进程的。</p>

<blockquote><p>opscripts show-cpu-and-memory</p></blockquote></li>
<li><p>进入jvm调试交互命令行，包含对java栈、堆、线程、gc等状态的查看</p>

<blockquote><p>opscripts jvm [pid]</p></blockquote></li>
</ul>


<h2>JVM配置示例</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-server #64位机器下默认
</span><span class='line'>-Xms6000M #最小堆大小
</span><span class='line'>-Xmx6000M #最大堆大小
</span><span class='line'>-Xmn500M #新生代大小
</span><span class='line'>-Xss256K #栈大小
</span><span class='line'>-XX:PermSize=500M (JDK7)
</span><span class='line'>-XX:MaxPermSize=500M (JDK7)
</span><span class='line'>-XX:MetaspaceSize=128m  （JDK8）
</span><span class='line'>-XX:MaxMetaspaceSize=512m（JDK8）
</span><span class='line'>-XX:SurvivorRatio=65536
</span><span class='line'>-XX:MaxTenuringThreshold=0 #晋升到老年代需要的存活次数,设置为0时，survivor区失去作用，一次minor gc，eden中存活的对象就会进入老年代，默认是15，使用CMS时默认是4
</span><span class='line'>-Xnoclassgc #不做类的gc
</span><span class='line'>#-XX:+PrintCompilation #输出jit编译情况，慎用
</span><span class='line'>-XX:+TieredCompilation #启用多层编译，jd8默认开启
</span><span class='line'>-XX:CICompilerCount=4 #编译器数目增加
</span><span class='line'>-XX:-UseBiasedLocking #取消偏向锁
</span><span class='line'>-XX:AutoBoxCacheMax=20000 #自动装箱的缓存数量，如int默认缓存为-128~127
</span><span class='line'>-Djava.security.egd=file:/dev/./urandom #替代默认的/dev/random阻塞生成因子
</span><span class='line'>-XX:+AlwaysPreTouch #启动时访问并置零内存页面，大堆时效果比较好
</span><span class='line'>-XX:-UseCounterDecay #禁止JIT调用计数器衰减。默认情况下，每次GC时会对调用计数器进行砍半的操作，导致有些方法一直是个温热，可能永远都达不到C2编译的1万次的阀值。
</span><span class='line'>-XX:ParallelRefProcEnabled=true # 默认为false，并行的处理Reference对象，如WeakReference
</span><span class='line'>-XX:+DisableExplicitGC #此参数会影响使用堆外内存，会造成oom，如果使用NIO,请慎重开启
</span><span class='line'>#-XX:+UseParNewGC #此参数其实在设置了cms后默认会启用，可以不用设置
</span><span class='line'>-XX:+UseConcMarkSweepGC #使用cms垃圾回收器
</span><span class='line'>#-XX:+UseCMSCompactAtFullCollection #是否在fullgc是做一次压缩以整理碎片，默认启用
</span><span class='line'>-XX:CMSFullGCsBeforeCompaction=0 #full gc触发压缩的次数
</span><span class='line'>#-XX:+CMSClassUnloadingEnabled #如果类加载不频繁，也没有大量使用String.intern方法，不建议打开此参数，况且jdk7后string pool已经移动到了堆中。开启此项的话，即使设置了Xnoclassgc也会进行class的gc, 但是某种情况下会造成bug：https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=5&cad=rja&uact=8&ved=0ahUKEwjR16Wf6MHQAhWLrVQKHfLdCe4QFgg8MAQ&url=https%3A%2F%2Fblogs.oracle.com%2Fpoonam%2Fentry%2Fjvm_hang_with_cms_collector&usg=AFQjCNFNtkw6jHM-uyz-Wjri3LtAVXWJ8g&sig2=BFxSfHc-AIek18fEhY07mg。
</span><span class='line'>#-XX:+CMSParallelRemarkEnabled #并行标记, 默认开启, 可以不用设置
</span><span class='line'>#-XX:+CMSScavengeBeforeRemark #强制remark之前开始一次minor gc，减少remark的暂停时间，但是在remark之后也将立即开始又一次minor gc
</span><span class='line'>-XX:CMSInitiatingOccupancyFraction=90 #触发full gc的内存使用百分比
</span><span class='line'>-XX:+PrintClassHistogram #打印类统计信息
</span><span class='line'>-XX:+PrintHeapAtGC #打印gc前后的heap信息
</span><span class='line'>-XX:+PrintGCDetails #以下都是为了记录gc日志
</span><span class='line'>-XX:+PrintGCDateStamps
</span><span class='line'>-XX:+PrintGCApplicationStoppedTime #打印清晰的GC停顿时间外，还可以打印其他的停顿时间，比如取消偏向锁，class 被agent redefine，code deoptimization等等
</span><span class='line'>-XX:+PrintTenuringDistribution #打印晋升到老年代的年龄自动调整的情况(并行垃圾回收器启用UseAdaptiveSizePolicy参数的情况下以及其他垃圾回收期也会动态调整，从最开始的MaxTenuringThreshold变成占用当前堆50%的age)
</span><span class='line'>#-XX:+UseAdaptiveSizePolicy # 此参数在并行回收器时是默认开启的会根据应用运行状况做自我调整，如MaxTenuringThreshold、survivor区大小等，其他情况下最好不要开启
</span><span class='line'>#-XX:StringTableSize #字符串常量池表大小(hashtable的buckets的数目)，java 6u30之前无法修改固定为1009，后面的版本默认为60013，可以通过此参数设置
</span><span class='line'>-XX:GCTimeLimit=98 #gc占用时间超过多少抛出OutOfMemoryError
</span><span class='line'>-XX:GCHeapFreeLimit=2 #gc回收后小于百分之多少抛出OutOfMemoryError
</span><span class='line'>-Xloggc:/home/logs/gc.log</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何读取ClassPath下的资源]]></title>
    <link href="http://www.rowkey.me/blog/2017/02/20/read-classpath-resource/"/>
    <updated>2017-02-20T22:21:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/02/20/read-classpath-resource</id>
    <content type="html"><![CDATA[<p>最近在写一些公共组件时，碰到了需要读取classpath下文件的场景。也突然想起其实之前有很多场景牵扯到读取类加载路径下的文件内容、路径，包括非jar包和jar包中的。总结一下，以备后续使用。</p>

<!--more-->


<p>由于获取类路径下的资源文件的都是基于URL的，因此这里需要先讲述一下URL的概念。URL(Uniform Resource Locator)即统一资源定位器，指向互联网资源的指针，是一种具体的资源。其一般的形式，如：</p>

<p><code>scheme:[//host][:port][path][?query][#fragment]</code></p>

<p>scheme包括：http、https、file、jar等。一个例子：<code>file:/User/root/test.jar?time=123431212</code>, 其中：schema为file，path为<code>/User/root/test.jar</code>, query为time=123431212。</p>

<p>这里需要区分URL和URI。URI, Uniform Resource Identifier，统一资源标识符，用来唯一的标识一个资源。其一般形式：</p>

<p><code>[scheme:][//authority][path][?query][#fragment]</code></p>

<p>其中，authority为[user-info@]host[:port]</p>

<p>可见，URL是一种具体的URI，只不过其scheme是非空的，它不仅仅标识一个资源，也能定位一个资源（即通过url能够访问到这个资源），因此其必须是绝对地址，即使是相对url，其本质也是相对于某绝对url来讲的，也是一个绝对地址。而URI可以是绝对的也可以是相对的，只要能够标识即可。</p>

<p>此外，URL和URI的不同之处还在于前者不提供对标准RFC2396规定的特殊字符的转义，因此需要调用者自己对URL各组成部分进行encode。而java.net.URI则会提供转义功能。这两者可以通过URI.toURL()和URL.toURI()来互相转换。</p>

<p>这里需要指出的是，如果是想直接读取类路径下的资源的内容，那么使用下面的方法是万能的。</p>

<p><code>ClassLoader.getResourceAsStream(String classpathRecourcePath)</code></p>

<p>需要注意的是有时候jar包中的类并非和你应用的类使用的是同一类加载器(写intellij插件的时候就会存在这种问题)，这时候需要选择对应的ClassLoader。</p>

<p>此外，有些场景是需要获取到类路径下的资源路径信息的，可以选用以下三种方法：</p>

<ul>
<li><p>ClassLoader.getResource(String classpathFilePath)`</p>

<p>  此方法的加载过程类似“双亲委派机制”，当父加载器无法获取到资源时，自己才去尝试获取。但需要注意的是以 / 开头的资源是在类加载器目录下的资源，并非指的是当前应用的类加载路径下的资源。如果资源是位于classpath下的不要以 / 开头。</p></li>
<li><p><code>Class&lt;?&gt;.getResource(String classpathFilePath)</code></p>

<p>  此方法最终还是对上面的方法的调用。不同的是，此方法会对传入的路径参数做处理，并且会尝试去获取类加载器。</p>

<ul>
<li>当路径信息不以 / 开头时，获取的是相对于当前类所在路径的相对资源</li>
<li>当路径信息以 / 开头时，则获取的是当前应用类加载路径下的资源</li>
</ul>
</li>
<li><p><code>Class&lt;?&gt;.getProtectionDomain().getCodeBase.getLocation()</code></p>

<p>  此方法获取的是此类所处于的保护域的路径信息，当位于jar包中时，返回的是jar包的路径信息，非jar包则返回的是应用的类加载路径的地址。此方法的一个常见使用场景就是使用嵌入式jetty或者tomcat时对于webappBase的设置。</p></li>
</ul>


<p>还需要提到的一点是：当你想使用File类来处理scheme为file的资源时，可以使用URL的getFile方法获取其path和query信息(URL的getPath方法返回的仅仅包含path部分)。但如果你的资源是位于jar包中的，那么获取到的URL信息是以<strong><em>jar:file</em></strong>开头的，并不能用此方式处理。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一些架构设计原则]]></title>
    <link href="http://www.rowkey.me/blog/2017/01/15/arch-spec/"/>
    <updated>2017-01-15T22:21:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2017/01/15/arch-spec</id>
    <content type="html"><![CDATA[<p><img src="http://www.rowkey.me/images/blog_images/arch-spec.png" alt="" /></p>

<p>详细见：<a href="http://www.rowkey.me/blog/2017/08/24/arch/">谈谈架构</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译]JDK自带工具之问题排查场景示例]]></title>
    <link href="http://www.rowkey.me/blog/2016/11/16/java-trouble-shooting/"/>
    <updated>2016-11-16T22:21:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2016/11/16/java-trouble-shooting</id>
    <content type="html"><![CDATA[<h2>目录</h2>

<ul>
<li><a href="#%E5%BC%95%E8%A8%80">引言</a></li>
<li><a href="#%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E5%9C%BA%E6%99%AF">问题排查场景</a>

<ul>
<li><a href="#%E8%8E%B7%E5%8F%96%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84JVM%E5%88%97%E8%A1%A8">获取正在运行的JVM列表</a></li>
<li><a href="#Java%E5%A0%86%E7%9A%84DUMP">Java堆的DUMP</a></li>
<li><a href="#%E5%88%86%E6%9E%90%E5%A0%86%E7%9B%B4%E6%96%B9%E5%9B%BE">分析堆直方图</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8BDump">线程Dump</a></li>
<li><a href="#%E8%BF%90%E8%A1%8CJava%E9%A3%9E%E8%A1%8C%E8%AE%B0%E5%BD%95%E5%99%A8(Java%20Flight%20Recorder">运行Java飞行记录器(Java Flight Recorder)</a>)</li>
<li><a href="#%E5%90%8E%E8%AE%B0">后记</a></li>
</ul>
</li>
</ul>


<p>最近看到了大量关于java性能调优、故障排查的文章，自己也写了一篇<a href="http://www.rowkey.me/blog/2016/11/02/java-profile/">Java调优经验谈</a>。接着此篇文章，其实一直打算写写一些常用调优工具以及它们的惯常用法的。后来在<a href="http://java-performance.info">http://java-performance.info</a>这个站点上看到了类似的一篇博文，自我感觉很有指导意义。于是决定翻译+重组织一下此篇文章：<a href="http://java-performance.info/java-server-application-troubleshooting-using-jdk-tools/">Java server application troubleshooting using JDK tools</a>。</p>

<h2><a name='引言'></a>引言</h2>

<p>在Java世界中，我们的很多开发工作从编码、调试到调优都在使用GUI工具。我们经常尝试在本地构建一套和线上一样的环境从而使得问题能够重现，进而使用我们常用的工具来排查定位故障。但不幸的是，很多情况下是无法在本地重现线上问题的。例如，我们没有权限获取真实客户端提交到线上服务端的数据。</p>

<p>由此，很多时候都是需要远程来排查线上服务器上发生的问题。但是如果单单只有一个JRE的话，你也不可能有合适的办法来进行排查。你需要JDK或者第三方的工具。有时候使用JDK提供的工具就是最可取的方案，毕竟，在线上环境使用第三方工具有时候会牵扯到权限的问题。</p>

<p>一般情况下，在线上环境安装JDK发布版本可以让排查进行地更高效。建议安装使用最新的Java7/8 JDK或者构建与线上JRE匹配的一些工具(原文作者不建议安装jdk的发布版本，而是建议根据实际需求逐渐地安装其中的工具)。</p>

<!--more-->


<h2><a name='问题排查场景'></a>问题排查场景</h2>

<h3><a name='获取正在运行的JVM列表'></a>获取正在运行的JVM列表</h3>

<p>为了开始排查工作，我们首先需要获取正在运行的jvm进程列表，包括进程id、命令行参数等。有时候仅仅这一步就可以定位到问题，例如，同样的app实例被重复启动在并发做同样的事情(破坏输出文件、重新打开sockets或者其他愚蠢的事情)。</p>

<p>使用<strong>jcmd</strong>不加任何参数即可获取jvm进程列表</p>

<pre><code>25691 org.apache.catalina.startup.Bootstrap start
20730 org.apache.catalina.startup.Bootstrap start
26828 sun.tools.jcmd.JCmd
3883 org.apache.catalina.startup.Bootstrap start
</code></pre>

<p>使用<strong>jcmd <PID> help</strong>能够获取某个jvm进程其他可用的诊断命令。例如：</p>

<pre><code>[root@test-172-16-0-34-ip ~]# jcmd 3883 help
3883:
The following commands are available:
VM.commercial_features
ManagementAgent.stop
ManagementAgent.start_local
ManagementAgent.start
Thread.print
GC.class_histogram
GC.heap_dump
GC.run_finalization
GC.run
VM.uptime
VM.flags
VM.system_properties
VM.command_line
VM.version
help
</code></pre>

<p>输入<strong>jcmd <PID> <COMMAND_NAME></strong>可以运行一个诊断命令或者获取到参数错误信息。</p>

<pre><code>[root@test-172-16-0-34-ip ~]# jcmd 3883 GC.heap_dump
3883:
java.lang.IllegalArgumentException: Missing argument for diagnostic command 
</code></pre>

<p>通过<strong>jcmd <PID> help <COMMAND_NAME></strong>你能够获取此诊断命令更多的信息。如下是<strong>GC.heap_dump</strong>命令的help。</p>

<pre><code>[root@test-172-16-0-34-ip ~]# jcmd 3883 help GC.heap_dump
3883:
GC.heap_dump
Generate a HPROF format dump of the Java heap.

Impact: High: Depends on Java heap size and content. Request a full GC unless the '-all' option is specified.

Syntax : GC.heap_dump [options] &lt;filename&gt;

Arguments:
    filename :  Name of the dump file (STRING, no default value)

Options: (options must be specified using the &lt;key&gt; or &lt;key&gt;=&lt;value&gt; syntax)
    -all : [optional] Dump all objects, including unreachable objects (BOOLEAN, false)  
</code></pre>

<h3><a name='Java堆的DUMP'></a>Java堆的DUMP</h3>

<p>jcmd提供了输出HPROF格式的堆dump接口。运行<strong>jcmd <PID> GC.heap_dump <FILENAME></strong>即可。注意这里的FILENAME是相对于运行中的jvm目录来说的，因此避免找不到dump的文件，这里推荐使用绝对路径。此外，也建议使用.hprof作为输出文件的扩展名。</p>

<p>在堆dump完成之后，你可以复制此文件到本地用VisualVM或者用jmc的JOverflow插件打开，进而通过分析堆的状况定位内存问题。</p>

<p>需要注意的两点：</p>

<ul>
<li>还有很多可以打开hprof文件进行分析的工具：NetBeans, Elipse的MAT，jhat等等。用你最熟悉的即可。</li>
<li>同样可以使用<strong>jmap -dump:live,file=<FILE_NAME> <PID></strong>来产生堆dump文件，但是官方文档标注了此工具为unsupported的。虽然我们绝大多数人都会认为JDK中unsupported的特性会永远存在，但是事实并非这样：<a href="http://openjdk.java.net/jeps/240">JEP 240</a>, <a href="http://openjdk.java.net/jeps/241">JEP 241</a>。</li>
</ul>


<h3><a name='分析堆直方图'></a>分析堆直方图</h3>

<p>如果正在排查内存泄漏问题，你可能想要知道堆中某种类型的存活对象数目。例如，某一时刻某些类应该只有一个实例(单例模式)，但是此类的另外一个或者多个实例却已经到了老年代，但是事实上它们不应该能够被GC roots访问到。</p>

<p>运行以下命令可以打印出堆直方图(同时也打印出存活对象的数目)：</p>

<pre><code>jcmd &lt;PID&gt; GC.class_histogram
jmap -histo:live &lt;PID&gt;
</code></pre>

<p>输出如下：</p>

<pre><code>    num     #instances         #bytes  class name
----------------------------------------------
   1:         37083       48318152  [B
   2:        235781       22496784  [C
   3:        103958       16069448  &lt;constMethodKlass&gt;
   4:        482361       15435552  java.util.HashMap$Entry
   5:        103958       14152480  &lt;methodKlass&gt;
   6:          9576       11192168  &lt;constantPoolKlass&gt;
   7:        186264       10430784  com.mysql.jdbc.ConnectionPropertiesImpl$BooleanConnectionProperty
   8:        274109        8771488  java.util.Hashtable$Entry
   9:          9576        7210152  &lt;instanceKlassKlass&gt;
  10:          7972        6404256  &lt;constantPoolCacheKlass&gt;
  11:        229637        5511288  java.lang.String
  12:         48471        5428752  java.net.SocksSocketImpl
  13:         21599        3859672  [Ljava.util.HashMap$Entry;
</code></pre>

<p>这里的以byte为单位的占用大小是浅尺寸(shallow size)，并没有包括子对象的大小。其实这个事实很容易由char[]和String的统计数据注意到：这俩的实例数目是差不多的，但是char[]的占用大小要大很多，就是因为String并未包含下面的char[]的大小。</p>

<p>有了堆直方图信息，你就可以grep/search类的名字从而获取存活实例的数目。如果你发现某些类的实例数量比期望要大很多，你就可以做heap dump，然后用任意的heap分析工具来分析问题。</p>

<h3><a name='线程Dump'></a>线程Dump</h3>

<p>很多时候，应用会呈现出“卡在那里”的情形。这里有很多种卡住的状况：死锁、cpu密集运算。为了定位到问题所在需要知道线程在做什么、持有了什么锁等等。</p>

<p>Java中有两种锁：基于sychronized和Object.wait/notifyAll方法的原始锁以及java5引入的java.util.concurrent锁。这俩种锁的不同之处主要在于前者是限制在进入synchronized部分的地方的栈帧(stack frame)中的，并且会一直在线程dump中存在。后者却并不限制在栈帧中，你可以在一个方法中进入锁，在另一方法中解锁。因此，thread dump有时候并没有包含这些信息。尽管如此，还是应该使用thread dump来查看线程信息排查问题。</p>

<p>这里有三种方法可以打印应用的thread dump。</p>

<pre><code>kill -3 &lt;PID&gt; #仅限Linux平台
jstack &lt;PID&gt;
jcmd &lt;PID&gt; Thread.print
</code></pre>

<h3><a name='运行Java飞行记录器(Java Flight Recorder)'></a>运行Java飞行记录器(Java Flight Recorder)</h3>

<p>上面讲到的工具都是作为快速的查看诊断工具的。如果要深入分析问题，可以选择使用内置的Java飞行记录器:<a href="http://java-performance.info/oracle-java-mission-control-overview/">Java Mission Control</a>。</p>

<p>运行JFR需要三步：</p>

<ol>
<li><p>创建一个包含了你自己配置的JFR模板文件。运行<strong>jmc</strong>, 然后<strong>Window->Flight Recording Template Manage</strong>菜单。准备好档案后，就可以导出文件，并移动到要排查问题的环境中。</p></li>
<li><p>由于JFR需要JDK的商业证书，这一步需要解锁jdk的商业特性。</p>

<pre><code> jcmd &lt;PID&gt; VM.unlock_commercial_features
</code></pre></li>
<li><p>最后你就可以启动JFR。</p>

<pre><code> jcmd &lt;PID&gt; JFR.start name=test duration=60s settings=template.jfc filename=output.jfr
</code></pre>

<p> 上述命令立即启动JFR并开始使用<strong>templayte.jfc</strong>的配置收集60s的JVM信息，输出到<strong>output.jfr</strong>中。</p></li>
</ol>


<p>一旦记录完成之后，就可以复制.jfr文件到你的工作环境使用jmc GUI来分析。它几乎包含了排查jvm问题需要的所有信息，包括堆dump时的异常信息。</p>

<h3><a name='后记'></a>后记</h3>

<p>本文基本上是对英文原文的翻译，主要描述了几个常见问题的排查场景。</p>

<p>不得不说的是，JDK自带的工具是非常强大的。用好了这些工具其实已经足以应付绝大多数的Java问题排查场景。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[译]使用Groovy的AST Transformation实现DSL]]></title>
    <link href="http://www.rowkey.me/blog/2016/11/12/groovy-ast/"/>
    <updated>2016-11-12T21:21:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2016/11/12/groovy-ast</id>
    <content type="html"><![CDATA[<p>最近在看一些java开源项目时，发现不少是用gradle做为项目构建工具的。之前虽然也用过gradle，但是却没怎么仔细留意build.gradle的语法是groovy的。但这次再怎么看也觉得里面的好多语法都和以前用过的groovy都联系不到一起。各种懵逼状态。。。后来阅读了这篇文章，算是解答了一些疑问：<a href="http://www.cnblogs.com/CloudTeng/p/3418072.html">http://www.cnblogs.com/CloudTeng/p/3418072.html</a>。但是对于下面这种写法，还是不知道是怎么回事：</p>

<pre><code>task copyFile(type: Copy){
    from 'xml'
    into 'destination'
}
</code></pre>

<p>copyFile做为task名称竟然不是一个字符串，阅读了groovy的文档也没发现字符串可以省略引号的说明(php中引号倒是可以省略），此外一个方法后面跟一个参数然后这个参数又跟着一个括号，这又是什么语法。。。凭直觉觉得这里的copyFile应该是一个方法，但是这时候copyFile还没有定义啊。。。</p>

<p>带着以上疑问，去翻了一下groovy的官方文档，凭感觉觉得gradle是利用了groovy的ast trasnfomation，也就是抽象语法树转换(故名思议，也就是能够转换groovy的语法树从而创造自己的一套语法)。那么到底是不是这样呢？<a href="http://blog.csdn.net/zxhoo/article/details/29830529">http://blog.csdn.net/zxhoo/article/details/29830529</a>给出了解释并证明了这个结论。但是groovy的ast transformation到底是什么东西呢？国外有一篇博客给出了比较清晰明了的讲述：<a href="http://www.jroller.com/DhavalDalal/entry/a_case_for_using_groovy">http://www.jroller.com/DhavalDalal/entry/a_case_for_using_groovy</a>。以下即对此篇博文的翻译。</p>

<!--more-->


<hr />

<p>为了给出此问题的一个上下文，在我目前的项目上创建了一个使用Groovy作为主要语言的内嵌DSL。这个DSL和MongoDB lingo类似，下面是一个例子：</p>

<pre><code>// Sample Delta file 
use test
db.customers.add("{'city' : 'Please Set City', 'pin':  'Please Pin code' }")

//Increment age field by 1
db.customers.transform('age', "{ $add: ["$age", 1] }")

// Set context to transactions db
use transactions

// add to orders collection a nested document
db.orders.add('{"dispatch" : { "status" : "Default", "address": { "line1" : "Road", "city": "City" }}}')
</code></pre>

<p>和Mongo Shell类似的，我想要支持在命令参数中使用单引号和双引号包裹住的字符串。和javascript一样，你可以在字符串内部使用引号，只要不要和外部包裹字符串的引号匹配就可以。为了实现这些，我现在遇到两个问题：</p>

<ol>
<li><strong><em>use</em></strong> 是Groovy的一个供Groovy Categories使用的默认方法，和Scala中的implicit以及c#中的扩展方法类似。</li>
<li>在add、tranform函数中的双引号参数是Groovy中的GString，可以使用$来做字符串替换-在Groovy的世界中，你可能听过&#8221;You need a $ in GString ;)&ldquo;这种说法。它会解析出现在$后面的表达式然后替换为表达式的字符串输出。此外，GString是延迟解析的，只有当toString被调用或者做为参数传递给函数的时候，GString才会对其中的$做解析。因此，上面的例子中age并没有定义，会在GString被解析的时候产生问题。</li>
</ol>


<p>当然，我们可以做一些hack的事情来解决上面的问题。我们不用use而是换成using来解决第一个问题。但是第二个问题，我怎样才能阻止人们不在函数参数中使用双引号字符串呢？在文档中注明规范意味着被动并且依赖于遵守规范的开发者。因此，这样做并不很hack。上面两个问题看起来都像是编译级别的问题。下面就讲述我是如何一石二鸟解决这些问题的。</p>

<p>Groovy提供了访问抽象语法树并转换它的方法。一个AST是编译器在编译阶段生成的中间表示。这里讲的AST指的是能够产生另外的翻译或者字节码。Groovy以<a href="http://groovy.codehaus.org/gapi/org/codehaus/groovy/transform/ASTTransformation.html">ASTTransformation</a>的形式提供了一个钩子让我们可以在编译阶段添加、修改语法树。一个实现了此接口的类必须以<a href="http://groovy.codehaus.org/gapi/org/codehaus/groovy/transform/GroovyASTTransformation.html">@GroovyASTTransformation</a>注解，这样Groovy才能知道应该在哪一个阶段运行。这样我可以处理全局AST转换，其中visit方法会为sourceUnit(原始的源代码)调用一次，并且我会忽略ASTNode[]中的第一个和第二个元素。下面是我的ASTTransformation代码：</p>

<pre><code>@Slf4j
@GroovyASTTransformation
public class StatementTransformation implements ASTTransformation {
  private def transformations = ['use' : 'using']

  @Override
  void visit(ASTNode[] nodes, SourceUnit source) {
    log.info("Source name = ${source.name}")
    ModuleNode ast = source.ast
    def blockStatement = ast.statementBlock

    blockStatement.visit(new CodeVisitorSupport() {
      void visitConstantExpression(ConstantExpression ce) {
        def name = ce.value
        if (transformations.containsKey(name)) {
          def newName = transformations[name]
          log.debug("Transform Name =&gt; $name -&gt; $newName")
          ce.value = newName
        } else {
          log.debug("Skip Name =&gt; $name")
        }
      }

      public void visitArgumentlistExpression(ArgumentListExpression ale) {
        log.debug("Arg List $ale.expressions")
        def expressions = ale.expressions
        expressions.eachWithIndex { expr, idx -&gt;
          if(expr.getClass() == GStringExpression) {
            log.debug("Transform GString =&gt; String ($expr.text)")
            expressions[idx] = new ConstantExpression(expr.text)
          }
        }
        log.debug("Transformed Arg List $ale.expressions")
        super.visitArgumentlistExpression(ale)
      }
    })
  }
}
</code></pre>

<ol>
<li>当遇到like, use, db, customers, add, transform, fn params等常量时，visitConstantExpression(&hellip;)会被调用。根据已经定义的transformations map(第四行)，相应的值会被简单重新赋值。(18行)</li>
<li>当调用函数时，visitArgumentlistExpression会被调用。在我的例子中db.customers.transform(&hellip;)和db.customers.add(&hellip;)是函数调用并且整个所有的参数都被传给了visitArgumentlistExpression方法。在GStringExpression出现的时候将它转换为了ConstantExpression(30行)。</li>
</ol>


<p>接下来看看如何使用上面的代码。</p>

<p>Reader读取所有的DSL文件，在的例子中，我们把它们叫做delta文件。对于每一个deleta文件，我创建了一个新的GroovyShell并让它去解析代码(delta文件中的)。这里的shell用我自定义的AST transformer做了相应的配置。shell解析出一个对象并传递给Parser。这样Pardser得到的结点其中的GString已经全被转换为了普通String，&#8217;use&#8217;也已经被转换为了&#8217;using&#8217;方法。</p>

<pre><code>@Slf4j
public class Reader {
  private def createNewShell() {
    def secureCustomizer = new SecureASTCustomizer()
    secureCustomizer.with {
      methodDefinitionAllowed = false // user will not be able to define methods
      importsWhitelist = [] // empty whitelist means imports are disallowed
      staticImportsWhitelist = [] // same for static imports
      staticStarImportsWhitelist = []
      ....
    }

    def astCustomizer = 
      new ASTTransformationCustomizer(new StatementTransformation())
    def config = new CompilerConfiguration()
    config.addCompilationCustomizers(secureCustomizer, 
                          astCustomizer)
    new GroovyShell(config)
  }

  public Tree read(final List&lt;File&gt; deltas) {
    def parser = new Parser()
    deltas.each { delta -&gt;
      def deltaName = delta.name
      def dslCode = """{-&gt; $delta.text}"""
      //shell evaluates once, hence create new each time
      def shell = createNewShell()
      def deltaObject = shell.evaluate(dslCode, deltaName)
      try {
        parser.parse(deltaObject)
      } catch (Throwable t) {
        throw new InvalidGrammar("$deltaName --&gt; ${t.message}")
      }
      shell = null
    }
    parser.ast()
  }
}
</code></pre>

<p>下面是Parser的代码。在自定义ast转换应用之后调用using(db)。这里聪明的读者会发现我是如何使用getProperty(Groovy元对象协议编程的一部分，和invokeMethod、methodmissing类似)来拦截住对象属性的访问来改变数据库上下文的。</p>

<pre><code>@Slf4j
class Parser {
  private Tree tree = new Tree()
  private def dbContext

  @CompileStatic
  def getProperty(String name) {
    log.debug("property name is: $name")
    if(name == 'db') {
      return dbContext
    }
    tree.using(name)
  }

  def using(db) {
     log.info "Setting db context to ${db.toString()}"
     dbContext = db
  }

  public Tree parse(Closure closure) {
    def cloned = closure.clone()
    cloned.delegate = this
    cloned.resolveStrategy = Closure.DELEGATE_FIRST
    cloned()
    tree
  }

  def ast() {
    tree
  }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JDK自带工具之概览]]></title>
    <link href="http://www.rowkey.me/blog/2016/11/03/jdk-tools/"/>
    <updated>2016-11-03T22:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2016/11/03/jdk-tools</id>
    <content type="html"><![CDATA[<p>在我们平常对java程序进行问题排查、性能调优时，如果没有合适的工具，很多时候会事倍功半，甚至无法继续进行下去。其实，jdk自身已经提供了很多强大的工具供我们使用。本文就对这些工具做一个概览性的描述。</p>

<p>笔者的开发环境是：OS X EI Captian 10.11.6</p>

<p>JDK版本：</p>

<pre><code>java version "1.8.0_92"
Java(TM) SE Runtime Environment (build 1.8.0_92-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.92-b14, mixed mode)
</code></pre>

<p>JAVA_HOME/bin下的工具截图如下：</p>

<p><img src="http://www.rowkey.me/images/blog_images/jdk-tools.png" alt="" /></p>

<!--more-->


<ul>
<li><p>appletviewer: 用于运行并浏览applet小程序。</p></li>
<li><p>extcheck: 扩展检测工具，主要用于检测指定jar文件与当前已安装的Java SDK扩展之间是否存在版本冲突。</p></li>
<li><p>idlj: IDL转Java编译器(IDL-to-Java Compiler)，用于为指定的IDL文件生成Java绑定。IDL意即接口定义语言(Interface Definition Language)。</p></li>
<li><p>jar: jar文件管理工具，主要用于打包压缩、解压jar文件。</p></li>
<li><p>jarsigner: jar密匙签名工具。</p></li>
<li><p>java: Java运行工具，用于运行.class字节码文件或.jar文件。</p></li>
<li><p>javac: Java编译工具(Java Compiler)，用于编译Java源代码文件。</p></li>
<li><p>javadoc: Java文档工具，主要用于根据Java源代码中的注释信息生成HTML格式的API帮助文档。</p></li>
<li><p>javafxpackager: JavaFX包装器，用于执行与封装或签名JavaFX应用有关的任务。JDK 8u20已经迁移此工具到javapackager。</p></li>
<li><p>javah: Java头文件工具，用于根据Java类生成C/C++头文件和源文件(主要用于JNI开发领域)。</p></li>
<li><p>javap: Java反编译工具，主要用于根据Java字节码文件反汇编为Java源代码文件。</p></li>
<li><p>javapackager: 执行针对Java应用程序和JavaFX应用程序的打包和签名的任务。包含了javafxpackager的功能。</p></li>
<li><p>jcmd: Java 命令行(Java Command)，用于向正在运行的JVM发送诊断命令请求。</p></li>
<li><p>jconsole: 图形化用户界面的监测工具，主要用于监测并显示运行于Java平台上的应用程序的性能和资源占用等信息。</p></li>
<li><p>jdeps: 用于分析Java class的依赖关系.</p></li>
<li><p>jdb: Java调试工具(Java Debugger)，主要用于对Java应用进行断点调试。</p></li>
<li><p>jhat: Java堆分析工具(Java Heap Analysis Tool)，用于分析Java堆内存中的对象信息。</p></li>
<li><p>jinfo: Java配置信息工具(Java Configuration Information)，用于打印指定Java进程、核心文件或远程调试服务器的配置信息。</p></li>
<li><p>jjs: 对Nashorn引擎的调用。<a href="http://www.infoq.com/cn/articles/nashorn">Nashorn</a>是基于Java实现一个轻量级高性能的JavaScript运行环境。</p></li>
<li><p>jmap: Java内存映射工具(Java Memory Map)，主要用于打印指定Java进程、核心文件或远程调试服务器的共享对象内存映射或堆内存细节。</p></li>
<li><p>jmc: Java任务控制工具(Java Mission Control)，主要用于HotSpot JVM的生产时间监测、分析、诊断。开发者可以使用jmc命令来创建JMC工具。 <a href="https://docs.oracle.com/javacomponents/jmc-5-5/jmc-user-guide/toc.htm">https://docs.oracle.com/javacomponents/jmc-5-5/jmc-user-guide/toc.htm</a></p></li>
<li><p>jps: JVM进程状态工具(JVM Process Status Tool)，用于显示目标系统上的HotSpot JVM的Java进程信息。</p></li>
<li><p>jrunscript: Java命令行脚本外壳工具(command line script shell)，主要用于解释执行javascript、groovy、ruby等脚本语言。</p></li>
<li><p>jsadebugd: Java可用性代理调试守护进程(Java Serviceability Agent Debug Daemon)，主要用于附加到指定的Java进程、核心文件，或充当一个调试服务器。</p></li>
<li><p>jstack: Java堆栈跟踪工具，主要用于打印指定Java进程、核心文件或远程调试服务器的Java线程的堆栈跟踪信息。</p></li>
<li><p>jstat: JVM统计监测工具(JVM Statistics Monitoring Tool)，主要用于监测并显示JVM的性能统计信息，包括gc统计信息。</p></li>
<li><p>jstatd: jstatd(VM jstatd Daemon)工具是一个RMI服务器应用，用于监测HotSpot JVM的创建和终止，并提供一个接口，允许远程监测工具附加到运行于本地主机的JVM上。</p></li>
<li><p>jvisualvm: JVM监测、故障排除、分析工具，主要以图形化界面的方式提供运行于指定虚拟机的Java应用程序的详细信息。</p></li>
<li><p>keytool: 密钥和证书管理工具，主要用于密钥和证书的创建、修改、删除等。主要用于获取或缓存Kerberos协议的票据授权票据。允许用户查看本地凭据缓存和密钥表中的条目(用于Kerberos协议)。Kerberos密钥表管理工具，允许用户管理存储于本地密钥表中的主要名称和服务密钥。</p></li>
<li><p>native2ascii: 本地编码到ASCII编码的转换器(Native-to-ASCII Converter)，用于&#8221;任意受支持的字符编码&#8221;和与之对应的&#8221;ASCII编码和(或)Unicode转义&#8221;之间的相互转换。</p></li>
<li><p>orbd: 对象请求代理守护进程(Object Request Broker Daemon)，它使客户端能够透明地定位和调用位于CORBA环境的服务器上的持久对象。</p></li>
<li><p>pack200: JAR文件打包压缩工具，它可以利用Java类特有的结构，对普通JAR文件进行高效压缩，以便于能够更快地进行网络传输。这是微软提供的对象包装程序，用于对象安装包。</p></li>
<li><p>policytool: 策略工具，用于管理用户策略文件(.java.policy)。</p></li>
<li><p>rmic: Java RMI 编译器，为使用JRMP或IIOP协议的远程对象生成stub、skeleton、和tie类，也用于生成OMG IDL。</p></li>
<li><p>rmid: Java RMI 激活系统守护进程，rmid启动激活系统守护进程，允许在虚拟机中注册或激活对象。</p></li>
<li><p>rmiregistry: Java 远程对象注册表，用于在当前主机的指定端口上创建并启动一个远程对象注册表。</p></li>
<li><p>schemagen: XML schema生成器，用于生成XML schema文件。</p></li>
<li><p>serialver: 序列版本命令，用于生成并返回serialVersionUID。</p></li>
<li><p>servertool: Java IDL 服务器工具，用于注册、取消注册、启动和终止持久化的服务器。</p></li>
<li><p>tnameserv: Java IDL瞬时命名服务。</p></li>
<li><p>unpack200: JAR文件解压工具，将一个由pack200打包的文件解压提取为JAR文件。</p></li>
<li><p>wsgen: XML Web Service 2.0的Java API，生成用于JAX-WS Web Service的JAX-WS便携式产物。</p></li>
<li><p>wsimport: XML Web Service 2.0的Java API，主要用于根据服务端发布的wsdl文件生成客户端存根及框架</p></li>
<li><p>xjc: 主要用于根据XML schema文件生成对应的Java类。</p></li>
</ul>


<h2>参考资料</h2>

<p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/toc.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/toc.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java调优经验谈]]></title>
    <link href="http://www.rowkey.me/blog/2016/11/02/java-profile/"/>
    <updated>2016-11-02T19:29:34+08:00</updated>
    <id>http://www.rowkey.me/blog/2016/11/02/java-profile</id>
    <content type="html"><![CDATA[<h2>目录</h2>

<ul>
<li><a href="#%E8%B0%83%E4%BC%98%E5%87%86%E5%A4%87">调优准备</a></li>
<li><a href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">性能分析</a></li>
<li><a href="#%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98">性能调优</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE">其他优化建议</a></li>
<li><a href="#JVM%E5%8F%82%E6%95%B0%E8%BF%9B%E9%98%B6">JVM参数进阶</a></li>
</ul>


<p>对于调优这个事情来说，一般就是三个过程：</p>

<ul>
<li>性能监控：问题没有发生，你并不知道你需要调优什么。此时需要一些系统、应用的监控工具来发现问题。</li>
<li>性能分析：问题已经发生，但是你并不知道问题到底出在哪里。此时就需要使用工具、经验对系统、应用进行瓶颈分析，以求定位到问题原因。</li>
<li>性能调优：经过上一步的分析定位到了问题所在，需要对问题进行解决，使用代码、配置等手段进行优化。</li>
</ul>


<p>Java调优也不外乎这三步。</p>

<p>此外，本文所讲的性能分析、调优等是抛开以下因素的：</p>

<ul>
<li>系统底层环境：硬件、操作系统等</li>
<li>数据结构和算法的使用</li>
<li>外部系统如数据库、缓存的使用</li>
</ul>


<!--more-->


<h2><a name='调优准备'></a>调优准备</h2>

<p>调优是需要做好准备工作的，毕竟每一个应用的业务目标都不尽相同，性能瓶颈也不会总在同一个点上。在业务应用层面，我们需要：</p>

<ul>
<li>需要了解系统的总体架构，明确压力方向。比如系统的哪一个接口、模块是使用率最高的，面临高并发的挑战。</li>
<li>需要构建测试环境来测试应用的性能，使用ab、loadrunner、jmeter都可以。</li>
<li>对关键业务数据量进行分析，这里主要指的是对一些数据的量化分析，如数据库一天的数据量有多少；缓存的数据量有多大等</li>
<li>了解系统的响应速度、吞吐量、TPS、QPS等指标需求，比如秒杀系统对响应速度和QPS的要求是非常高的。</li>
<li>了解系统相关软件的版本、模式和参数等，有时候限于应用依赖服务的版本、模式等，性能也会受到一定的影响。</li>
</ul>


<p>此外，我们还需要了解Java相关的一些知识：</p>

<ol>
<li>Java内存相关：这一部分可以参见<a href="http://www.rowkey.me/blog/2016/05/07/javamm/">谈谈Java内存管理</a>一文</li>
<li>对Java代码进行基准性能测试：可以使用JMH来进行，<a href="http://www.hollischuang.com/archives/1072">[译]使用JMH进行微基准测试：不要猜，要测试！</a>。</li>
<li>HotSpot VM相关知识：<a href="http://www.oracle.com/technetwork/cn/java/javase/tech/index-jsp-136373-zhs.html">http://www.oracle.com/technetwork/cn/java/javase/tech/index-jsp-136373-zhs.html</a></li>
<li>jdk自带各种java工具：<a href="http://www.rowkey.me/blog/2016/11/03/jdk-tools/">http://www.rowkey.me/blog/2016/11/03/jdk-tools/</a></li>
</ol>


<h2><a name='性能分析'></a>性能分析</h2>

<p>在系统层面能够影响应用性能的一般包括三个因素：CPU、内存和IO，可以从这三方面进行程序的性能瓶颈分析。</p>

<h3>CPU分析</h3>

<p>当程序响应变慢的时候，首先使用top、vmstat、ps等命令查看系统的cpu使用率是否有异常，从而可以判断出是否是cpu繁忙造成的性能问题。其中，主要通过us（用户进程所占的%）这个数据来看异常的进程信息。当us接近100%甚至更高时，可以确定是cpu繁忙造成的响应缓慢。一般说来，cpu繁忙的原因有以下几个：</p>

<ul>
<li>线程中有无限空循环、无阻塞、正则匹配或者单纯的计算</li>
<li>发生了频繁的gc</li>
<li>多线程的上下文切换</li>
</ul>


<p>确定好cpu使用率最高的进程之后就可以使用jstack来打印出异常进程的堆栈信息：</p>

<p><strong>jstack [pid]</strong></p>

<p><img src="http://www.rowkey.me/images/blog_images/profile/jstack.jpg" alt="jstack" /></p>

<p>接下来需要注意的一点是，Linux下所有线程最终还是以轻量级进程的形式存在系统中的，而使用jstack只能打印出进程的信息，这些信息里面包含了此进程下面所有线程（轻量级进程-LWP）的堆栈信息。因此，进一步的需要确定是哪一个线程耗费了大量CPU，此时可以使用top -p [processId] -H来查看，也可以直接通过ps -Le来显示所有进程,包括LWP的资源耗费信息。最后，通过在jstack的输出文件中查找对应的LWP的id即可以定位到相应的堆栈信息。其中需要注意的是线程的状态：RUNNABLE、WAITING等。对于Runnable的进程需要注意是否有耗费cpu的计算。对于Waiting的线程一般是锁的等待操作。</p>

<p>也可以使用jstat来查看对应进程的gc信息，以判断是否是gc造成了cpu繁忙。</p>

<p><strong>jstat -gcutil [pid]</strong></p>

<p><img src="http://www.rowkey.me/images/blog_images/profile/jstat.jpg" alt="jstat" /></p>

<p>还可以通过vmstat，通过观察内核状态的上下文切换(cs)次数，来判断是否是上下文切换造成的cpu繁忙。</p>

<p><strong>vmstat 1 5</strong></p>

<p><img src="http://www.rowkey.me/images/blog_images/profile/vmstat.jpg" alt="jstat" /></p>

<p>此外，有时候可能会由jit引起一些cpu飚高的情形，如大量方法编译等。这里可以使用-XX:+PrintCompilation这个参数输出jit编译情况，以排查jit编译引起的cpu问题。</p>

<h3>内存分析</h3>

<p>对Java应用来说，内存主要是由堆外内存和堆内内存组成。</p>

<ol>
<li><p>堆外内存</p>

<p> 堆外内存主要是JNI、Deflater/Inflater、DirectByteBuffer（nio中会用到）使用的。对于这种堆外内存的分析，还是需要先通过vmstat、sar、top、pidstat(这里的sar,pidstat以及iostat都是<a href="http://sebastien.godard.pagesperso-orange.fr/documentation.html">sysstat</a>软件套件的一部分，需要单独安装)等查看swap和物理内存的消耗状况再做判断的。此外，对于JNI、Deflater这种调用可以通过<a href="http://www.oschina.net/p/perftools">Google-preftools</a>来追踪资源使用状况。</p></li>
<li><p>堆内内存</p>

<p> 此部分内存为Java应用主要的内存区域。通常与这部分内存性能相关的有：</p>

<ul>
<li>创建的对象：这个是存储在堆中的，需要控制好对象的数量和大小，尤其是大的对象很容易进入老年代</li>
<li>全局集合：全局集合通常是生命周期比较长的，因此需要特别注意全局集合的使用</li>
<li>缓存：缓存选用的数据结构不同，会很大程序影响内存的大小和gc</li>
<li>ClassLoader：主要是动态加载类容易造成永久代内存不足</li>
<li>多线程：线程分配会占用本地内存，过多的线程也会造成内存不足</li>
</ul>


<p> 以上使用不当很容易造成：</p>

<ul>
<li>频繁GC -> Stop the world，使你的应用响应变慢</li>
<li>OOM，直接造成内存溢出错误使得程序退出。OOM又可以分为以下几种：

<ul>
<li>Heap space：堆内存不足</li>
<li>PermGen space：永久代内存不足</li>
<li>Native thread：本地线程没有足够内存可分配</li>
</ul>
</li>
</ul>


<p> 排查堆内存问题的常用工具是jmap，是jdk自带的。一些常用用法如下：</p>

<ul>
<li>查看jvm内存使用状况：jmap -heap <pid></li>
<li>查看jvm内存存活的对象：jmap -histo:live <pid></li>
<li>把heap里所有对象都dump下来，无论对象是死是活：jmap -dump:format=b,file=xxx.hprof <pid></li>
<li>先做一次full GC，再dump，只包含仍然存活的对象信息：jmap -dump:format=b,live,file=xxx.hprof <pid></li>
</ul>


<p> 此外，不管是使用jmap还是在OOM时产生的dump文件，可以使用Eclipse的MAT(MEMORY ANALYZER TOOL)来分析，可以看到具体的堆栈和内存中对象的信息。当然jdk自带的jhat也能够查看dump文件(启动web端口供开发者使用浏览器浏览堆内对象的信息)。此外，VisualVM也能够打开hprof文件，使用它的heap walker查看堆内存信息。</p>

<p> <img src="http://www.rowkey.me/images/blog_images/profile/jhat.png" alt="" /></p></li>
</ol>


<h3>IO分析</h3>

<p>通常与应用性能相关的包括：文件IO和网络IO。</p>

<ol>
<li><p>文件IO</p>

<p> 可以使用系统工具pidstat、iostat、vmstat来查看io的状况。这里可以看一张使用vmstat的结果图。</p>

<p> <img src="http://www.rowkey.me/images/blog_images/profile/io.png" alt="" /></p>

<p> 这里主要注意bi和bo这两个值，分别表示块设备每秒接收的块数量和块设备每秒发送的块数量，由此可以判定io繁忙状况。进一步的可以通过使用strace工具定位对文件io的系统调用。通常，造成文件io性能差的原因不外乎：</p>

<ul>
<li>大量的随机读写</li>
<li>设备慢</li>
<li>文件太大</li>
</ul>
</li>
<li><p>网络IO</p>

<p> 查看网络io状况，一般使用的是netstat工具。可以查看所有连接的状况、数目、端口信息等。例如：当time_wait或者close_wait连接过多时，会影响应用的相应速度。</p>

<pre><code> netstat -anp
</code></pre>

<p> <img src="http://www.rowkey.me/images/blog_images/profile/netstat.png" alt="" /></p>

<p> 此外，还可以使用tcpdump来具体分析网络io的数据。当然，tcpdump出的文件直接打开是一堆二进制的数据，可以使用wireshark阅读具体的连接以及其中数据的内容。</p>

<pre><code> tcpdump -i eth0 -w tmp.cap -tnn dst port 8080 #监听8080端口的网络请求并打印日志到tmp.cap中
</code></pre>

<p> 还可以通过查看/proc/interrupts来获取当前系统使用的中断的情况。</p>

<p> <img src="http://www.rowkey.me/images/blog_images/profile/interrupts.png" alt="" /></p>

<p> 各个列依次是：</p>

<pre><code> irq的序号， 在各自cpu上发生中断的次数，可编程中断控制器，设备名称（request_irq的dev_name字段）
</code></pre>

<p> 通过查看网卡设备的终端情况可以判断网络io的状况。</p></li>
</ol>


<h3>其他分析工具</h3>

<p>上面分别针对CPU、内存以及IO讲了一些系统/JDK自带的分析工具。除此之外，还有一些综合分析工具或者框架可以更加方便我们对Java应用性能的排查、分析、定位等。</p>

<ul>
<li><p>VisualVM</p>

<p>  这个工具应该是Java开发者们非常熟悉的一款java应用监测工具，原理是通过jmx接口来连接jvm进程，从而能够看到jvm上的线程、内存、类等信息。
  <img src="http://www.rowkey.me/images/blog_images/profile/visualvm.png" alt="" />
  如果想进一步查看gc情况，可以安装visual gc插件。此外，visualvm也有btrace的插件，可以可视化直观的编写btrace代码并查看输出日志。
  与VisualVm类似的，jconsole也是通过jmx查看远程jvm信息的一款工具，更进一步的，通过它还可以显示具体的线程堆栈信息以及内存中各个年代的占用情况，也支持直接远程执行MBEAN。当然，visualvm通过安装jconsole插件也可以拥有这些功能。
  <img src="http://www.rowkey.me/images/blog_images/profile/jconsole.png" alt="" />
  但由于这俩工具都是需要ui界面的，因此一般都是通过本地远程连接服务器jvm进程。服务器环境下，一般并不用此种方式。</p></li>
<li><p>Java Mission Control(jmc)</p>

<p>  此工具是jdk7 u40开始自带的，原来是JRockit上的工具，是一款采样型的集诊断、分析和监控与一体的非常强大的工具: <a href="https://docs.oracle.com/javacomponents/jmc-5-5/jmc-user-guide/toc.htm">https://docs.oracle.com/javacomponents/jmc-5-5/jmc-user-guide/toc.htm</a>。但是此工具是基于JFR(jcmd <PID> JFR.start name=test duration=60s settings=template.jfc filename=output.jfr)的，而开启JFR需要商业证书：jcmd <PID> VM.unlock_commercial_features。</p>

<p>  <img src="http://www.rowkey.me/images/blog_images/profile/jmc.png" alt="" /></p></li>
<li><p>Btrace</p>

<p>  这里不得不提的是btrace这个神器，它使用java attach api+ java agent + instrument api能够实现jvm的动态追踪。在不重启应用的情况下可以加入拦截类的方法以打印日志等。具体的用法可以参考<a href="http://calvin1978.blogcn.com/articles/btrace1.html">Btrace入门到熟练小工完全指南</a>。</p></li>
<li><p>Jwebap</p>

<p>  <a href="http://www.oschina.net/p/jwebap">Jwebap</a>是一款JavaEE性能检测框架，基于asm增强字节码实现。支持：http请求、jdbc连接、method的调用轨迹跟踪以及次数、耗时的统计。由此可以获取最耗时的请求、方法，并可以查看jdbc连接的次数、是否关闭等。但此项目是2006年的一个项目，已经将近10年没有更新。根据笔者使用，已经不支持jdk7编译的应用。如果要使用，建议基于原项目二次开发，同时也可以加入对redis连接的轨迹跟踪。当然，基于字节码增强的原理，也可以实现自己的JavaEE性能监测框架。</p>

<p>  <img src="http://www.rowkey.me/images/blog_images/profile/jwebap.png" alt="" /></p>

<p>  上图来自笔者公司二次开发过的jwebap，已经支持jdk8和redis连接追踪。</p></li>
<li><p>useful-scripts</p>

<p>  这里有一个本人参与的开源的项目：<a href="https://github.com/superhj1987/useful-scripts">https://github.com/superhj1987/useful-scripts</a>，封装了很多常用的性能分析命令，比如上文讲的打印繁忙java线程堆栈信息，只需要执行一个脚本即可。</p></li>
</ul>


<h2><a name='性能调优'></a>性能调优</h2>

<p>与性能分析相对应，性能调优同样分为三部分。</p>

<h3>CPU调优</h3>

<ul>
<li>不要存在一直运行的线程(无限while循环)，可以使用sleep休眠一段时间。这种情况普遍存在于一些pull方式消费数据的场景下，当一次pull没有拿到数据的时候建议sleep一下，再做下一次pull。</li>
<li>轮询的时候可以使用wait/notify机制</li>
<li>避免循环、正则表达式匹配、计算过多，包括使用String的format、split、replace方法(可以使用apache的commons-lang里的StringUtils对应的方法)，使用正则去判断邮箱格式(有时候会造成死循环)、序列/反序列化等。</li>
<li>结合jvm和代码，避免产生频繁的gc，尤其是full GC。</li>
</ul>


<p>此外，使用多线程的时候，还需要注意以下几点：</p>

<ul>
<li>使用线程池，减少线程数以及线程的切换</li>
<li>多线程对于锁的竞争可以考虑减小锁的粒度(使用ReetrantLock)、拆分锁(类似ConcurrentHashMap分bucket上锁), 或者使用CAS、ThreadLocal、不可变对象等无锁技术。此外，多线程代码的编写最好使用jdk提供的并发包、Executors框架以及ForkJoin等，此外<a href="http://ifeve.com/disruptor-getting-started/">Discuptor</a>和<a href="http://ifeve.com/introducing-actors-akka-notes-part-1/">Actor</a>在合适的场景也可以使用。</li>
</ul>


<h3>内存调优</h3>

<p>内存的调优主要就是对jvm的调优。</p>

<ul>
<li>合理设置各个代的大小。避免新生代设置过小(不够用，经常minor gc并进入老年代)以及过大(会产生碎片)，同样也要避免Survivor设置过大和过小。</li>
<li>选择合适的GC策略。需要根据不同的场景选择合适的gc策略。这里需要说的是，cms并非全能的。除非特别需要再设置，毕竟cms的新生代回收策略parnew并非最快的，且cms会产生碎片。此外，G1直到jdk8的出现也并没有得到广泛应用，并不建议使用。</li>
<li>jvm启动参数配置-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:[log_path]，以记录gc日志，便于排查问题。</li>
</ul>


<p>其中，对于第一点，具体的还有一点建议：</p>

<ul>
<li><strong>年轻代大小选择</strong>：响应时间优先的应用，尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生gc的频率是最小的。同时，也能够减少到达年老代的对象。吞吐量优先的应用，也尽可能的设置大，因为对响应时间没有要求，垃圾收集可以并行进行，建议适合8CPU以上的应用使用。</li>
<li><strong>年老代大小选择</strong>：响应时间优先的应用，年老代一般都是使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置小了，会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：

<ul>
<li>并发垃圾收集信息</li>
<li>持久代并发收集次数</li>
<li>传统GC信息</li>
<li>花在年轻代和年老代回收上的时间比例</li>
</ul>


<p>  一般吞吐量优先的应用都应该有一个很大的年轻代和一个较小的年老代。这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代存放长期存活对象。</p></li>
</ul>


<p>此外，<strong>较小堆引起的碎片问题</strong>：因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下配置：-XX:+UseCMSCompactAtFullCollection，使用并发收集器时，开启对年老代的压缩。同时使用-XX:CMSFullGCsBeforeCompaction=xx设置多少次Full GC后，对年老代进行压缩。</p>

<p>其余对于jvm的优化问题可见后面<strong>JVM参数进阶</strong>一节。</p>

<p>代码上，也需要注意：</p>

<ul>
<li>避免保存重复的String对象，同时也需要小心String.subString()与String.intern()的使用，尤其是后者其底层数据结构为StringTable，当字符串大量不重复时，会使得StringTable非常大(一个固定大小的hashmap，可以由参数-XX:StringTableSize=N设置大小)，从而影响young gc的速度。在jackson和fastjson中使用了此方法，某些场景下会引起gc问题: <a href="http://hellojava.info/?p=514">YGC越来越慢，为什么</a>。</li>
<li>尽量不要使用finalizer</li>
<li>释放不必要的引用：ThreadLocal使用完记得释放以防止内存泄漏，各种stream使用完也记得close。</li>
<li>使用对象池避免无节制创建对象，造成频繁gc。但不要随便使用对象池，除非像连接池、线程池这种初始化/创建资源消耗较大的场景，</li>
<li>缓存失效算法，可以考虑使用SoftReference、WeakReference保存缓存对象</li>
<li>谨慎热部署/加载的使用，尤其是动态加载类等</li>
<li><p>不要用Log4j输出文件名、行号，因为Log4j通过打印线程堆栈实现，生成大量String。此外，使用log4j时，建议此种经典用法，先判断对应级别的日志是否打开，再做操作，否则也会生成大量String。</p>

<pre><code>  if (logger.isInfoEnabled()) {
      logger.info(msg);
  }
</code></pre></li>
</ul>


<h3>IO调优</h3>

<p>文件IO上需要注意：</p>

<ul>
<li>考虑使用异步写入代替同步写入，可以借鉴redis的aof机制。</li>
<li>利用缓存，减少随机读</li>
<li>尽量批量写入，减少io次数和寻址</li>
<li>使用数据库代替文件存储</li>
</ul>


<p>网络IO上需要注意：</p>

<ul>
<li>和文件IO类似，使用异步IO、多路复用IO/事件驱动IO代替同步阻塞IO</li>
<li>批量进行网络IO,减少IO次数</li>
<li>使用缓存，减少对网络数据的读取</li>
<li>使用协程: <a href="http://colobu.com/2016/07/14/Java-Fiber-Quasar/">Quasar</a></li>
</ul>


<h2><a name='其他优化建议'></a>其他优化建议</h2>

<ul>
<li>算法、逻辑上是程序性能的首要，遇到性能问题，应该首先优化程序的逻辑处理</li>
<li>优先考虑使用返回值而不是异常表示错误</li>
<li>查看自己的代码是否对内联是友好的: <a href="http://www.infoq.com/cn/articles/Java-Application-Hostile-to-JIT-Compilation">你的Java代码对JIT编译友好么？</a></li>
</ul>


<p>此外，jdk7、8在jvm的性能上做了一些增强：</p>

<ul>
<li>通过-XX:+TieredCompilation开启JDK7的<a href="http://rednaxelafx.iteye.com/blog/1022095">多层编译（tiered compilation）支持</a>。多层编译结合了客户端C1编译器和服务端C2编译器的优点(客户端编译能够快速启动和及时优化，服务器端编译可以提供更多的高级优化)，是一个非常高效利用资源的切面方案。在开始时先进行低层次的编译，同时收集信息，在后期再进一步进行高层次的编译进行高级优化。<strong>需要注意的一点：</strong>这个参数会消耗比较多的内存资源，因为同一个方法被编译了多次，存在多份native内存拷贝，建议把code cache调大一点儿（-XX:+ReservedCodeCacheSize，InitialCodeCacheSize）。否则有可能由于code cache不足，jit编译的时候不停的尝试清理code cache，丢弃无用方法，消耗大量资源在jit线程上。</li>
<li>Compressed Oops：压缩指针在jdk7中的server模式下已经默认开启。</li>
<li>Zero-Based Compressed Ordinary Object Pointers：当使用了上述的压缩指针时，在64位jvm上，会要求操作系统保留从一个虚拟地址0开始的内存。如果操作系统支持这种请求，那么就开启了Zero-Based Compressed Oops。这样可以使得无须在java堆的基地址添加任何地址补充即可把一个32位对象的偏移解码成64位指针。</li>
<li>逃逸分析(Escape Analysis): Server模式的编译器会根据代码的情况，来判断相关对象的逃逸类型，从而决定是否在堆中分配空间，是否进行标量替换(在栈上分配原子类型局部变量)。此外，也可以根据调用情况来决定是否自动消除同步控制，如StringBuffer。这个特性从Java SE 6u23开始就默认开启。</li>
<li>NUMA Collector Enhancements：这个重要针对的是The Parallel Scavenger垃圾回收器。使其能够利用NUMA (Non Uniform Memory Access，即每一个处理器核心都有本地内存，能够低延迟、高带宽访问) 架构的机器的优势来更快的进行gc。可以通过-XX:+UseNUMA开启支持。</li>
</ul>


<p><strong>此外，网上还有很多过时的建议，不要再盲目跟随</strong>:</p>

<ul>
<li>变量用完设置为null，加快内存回收，这种用法大部分情况下并没有意义。一种情况除外：如果有个Java方法没有被JIT编译但里面仍然有代码会执行比较长时间，那么在那段会执行长时间的代码前显式将不需要的引用类型局部变量置null是可取的。具体的可以见R大的解释：<a href="https://www.zhihu.com/question/48059457/answer/113538171">https://www.zhihu.com/question/48059457/answer/113538171</a></li>
<li>方法参数设置为final，这种用法也没有太大的意义，尤其在jdk8中引入了effective final，会自动识别final变量。</li>
</ul>


<h2><a name='JVM参数进阶'></a>JVM参数进阶</h2>

<p>jvm的参数设置一直是比较理不清的地方，很多时候都搞不清都有哪些参数可以配置，参数是什么意思，为什么要这么配置等。这里主要针对这些做一些常识性的说明以及对一些容易让人进入陷阱的参数做一些解释。</p>

<p><strong><em>以下所有都是针对Oracle/Sun JDK 6来讲</em></strong></p>

<ol>
<li><p>启动参数默认值</p>

<p> Java有很多的启动参数，而且很多版本都并不一样。但是现在网上充斥着各种资料，如果不加辨别的全部使用，很多是没有效果或者本来就是默认值的。一般的，我们可以通过使用java -XX:+PrintFlagsInitial来查看所有可以设置的参数以及其默认值。也可以在程序启动的时候加入-XX:+PrintCommandLineFlags来查看与默认值不相同的启动参数。如果想查看所有启动参数(包括和默认值相同的)，可以使用-XX:+PrintFlagsFinal。
 <img src="http://www.rowkey.me/images/blog_images/profile/flags-1.png" alt="" />
 <img src="http://www.rowkey.me/images/blog_images/profile/flags-2.png" alt="" /></p>

<p> 输出里“=”表示使用的是初始默认值，而“:=”表示使用的不是初始默认值，可能是命令行传进来的参数、配置文件里的参数或者是<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html">ergonomics</a>自动选择了别的值。</p>

<p> 此外，还可以使用jinfo命令显示启动的参数。</p>

<ul>
<li>jinfo -flags [pid] #查看目前启动使用的有效参数</li>
<li>jinfo -flag [flagName] [pid] #查看对应参数的值</li>
</ul>


<p> <strong>这里需要指出的是，当你配置jvm参数时，最好是先通过以上命令查看对应参数的默认值再确定是否需要设置。也最好不要配置你搞不清用途的参数，毕竟默认值的设置是有它的合理之处的。</strong></p></li>
<li><p>动态设置参数</p>

<p> 当Java应用启动后，定位到了是GC造成的性能问题，但是你启动的时候并没有加入打印gc的参数，很多时候的做法就是重新加参数然后重启应用。但这样会造成一定时间的服务不可用。最佳的做法是能够在不重启应用的情况下，动态设置参数。使用jinfo可以做到这一点(本质上还是基于jmx的)。</p>

<pre><code> jinfo -flag [+/-][flagName] [pid] #启用/禁止某个参数
 jinfo -flag [flagName=value] [pid] #设置某个参数
</code></pre>

<p> 对于上述的gc的情况，就可以使用以下命令打开heap dump并设置dump路径。</p>

<pre><code> jinfo -flag +HeapDumpBeforeFullGC [pid] 
 jinfo -flag +HeapDumpAfterFullGC [pid]
 jinfo -flag HeapDumpPath=/home/dump/dir [pid]
</code></pre>

<p> 同样的也可以动态关闭。</p>

<pre><code> jinfo -flag -HeapDumpBeforeFullGC [pid] 
 jinfo -flag -HeapDumpAfterFullGC [pid]
</code></pre>

<p> 其他的参数设置类似。</p></li>
<li><p>-verbose:gc 与 -XX:+PrintGCDetails</p>

<p> 很多gc推荐设置都同时设置了这两个参数，其实，只要打开了-XX:+PrintGCDetails，前面的选项也会同时打开，无须重复设置。</p></li>
<li><p>-XX:+DisableExplicitGC</p>

<p> 这个参数的作用就是使得system.gc变为空调用，很多推荐设置里面都是建议开启的。但是，如果你用到了NIO或者其他使用到堆外内存的情况，使用此选项会造成oom。可以用XX:+ExplicitGCInvokesConcurrent或XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses(配合CMS使用，使得system.gc触发一次并发gc)代替。</p>

<p> 此外，还有一个比较有意思的地方。如果你不设置此选项的话，当你使用了RMI的时候，会周期性地来一次full gc。这个现象是由于分布式gc造成的，为RMI服务。具体的可见此链接内容中与dgc相关的：<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/rmi/sunrmiproperties.html">http://docs.oracle.com/javase/6/docs/technotes/guides/rmi/sunrmiproperties.html</a></p></li>
<li><p>MaxDirectMemorySize</p>

<p> 此参数是设置的堆外内存的上限值。当不设置的时候为-1，此值为-Xmx减去一个survivor space的预留大小。</p></li>
<li><p>由于遗留原因，作用相同的参数</p>

<ul>
<li>-Xss 与 -XX:ThreadStackSize</li>
<li>-Xmn 与 -XX:NewSize，此外这里需要注意的是设置了-Xmn的话，NewRatio就没作用了。</li>
</ul>
</li>
<li><p>-XX:MaxTenuringThreshold</p>

<p> 使用工具查看此值默认值为15，但是选择了CMS的时候，此值会变成4。当此值设置为0时，所有eden里的活对象在经历第一次minor GC的时候就会直接晋升到old gen，survivor space直接就没用。<strong>还有值得注意的一点，当使用并行回收器时，此值是没有作用的，并行回收器默认是自动调整这些参数以求达到吞吐量最大的。</strong>此外，即使是使用CMS等回收器，晋升到老年代的age也不是不变的，当某一age的对象的大小达到年轻代的50%时，这个age会被动态调整为晋升年龄。</p></li>
<li><p>-XX:HeapDumpPath</p>

<p> 使用此参数可以指定-XX:+HeapDumpBeforeFullGC、-XX:+HeapDumpAfterFullGC、-XX:+HeapDumpOnOutOfMemoryError触发heap dump文件的存储位置。</p></li>
<li><p>-XX:+UseAdaptiveSizePolicy</p>

<p> 此参数在并行回收器时是默认开启的，会根据应用运行状况做自我调整，如MaxTenuringThreshold、survivor区大小等。其中第一次晋升老年代的年龄以InitialTenuringThreshold（默认为7）开始，后续会自动调整。如果希望跟踪每次minor GC后新的存活周期的阈值，可在启动参数上增加：-XX:+PrintTenuringDistribution。如果想要可以配置这些参数，可以关闭此选项，但paralle的性能很难达到最佳。其他垃圾回收期则慎重开启此开关。</p></li>
</ol>


<h2><a name='参考资料'></a>参考资料</h2>

<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/performance-enhancements-7.html">Java HotSpot™ Virtual Machine Performance Enhancements</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/index.html">Java HotSpot Virtual Machine Garbage Collection Tuning Guide </a></li>
<li><a href="http://hllvm.group.iteye.com/group/topic/27945">[HotSpot VM] JVM调优的&#8221;标准参数&#8221;的各种陷阱</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
